
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>lopaths.graph &#8212; Vector Movement Modelling Tools</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">VeMoMoTo</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">lopaths.graph</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for lopaths.graph</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Module implementing objects representing graphs and different algorithms to</span>
<span class="sd">find shortest and potential alternative paths.</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span> <span class="k">as</span> <span class="n">iterproduct</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">starmap</span><span class="p">,</span> <span class="n">count</span> <span class="k">as</span> <span class="n">itercount</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span> <span class="k">as</span> <span class="n">iterchain</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">Array</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span> <span class="k">as</span> <span class="n">ThreadQueue</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">SimpleQueue</span> <span class="k">as</span> <span class="n">MultiprocessingQueue</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.lib.recfunctions</span> <span class="k">as</span> <span class="nn">rfn</span>
<span class="kn">import</span> <span class="nn">sharedmem</span>

<span class="kn">from</span> <span class="nn">vemomoto_core.npcollections.FixedOrderedIntDict</span> <span class="kn">import</span> <span class="n">FixedOrderedIntDict</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.npcollections.intquickheapdict</span> <span class="kn">import</span> <span class="n">intquickheapdict</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.npcollections.npextc</span> <span class="kn">import</span> <span class="n">FlexibleArray</span><span class="p">,</span> <span class="n">FlexibleArrayDict</span><span class="p">,</span> \
    <span class="n">unique_tol</span><span class="p">,</span> <span class="n">find_next_nonzero2d</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.npcollections.npext</span> <span class="kn">import</span> <span class="n">fields_view</span><span class="p">,</span> <span class="n">add_alias</span><span class="p">,</span> <span class="n">add_names</span><span class="p">,</span> \
    <span class="n">FlexibleArrayDict</span> <span class="k">as</span> <span class="n">FlexibleArrayDictO</span><span class="p">,</span> <span class="n">csr_matrix_nd</span><span class="p">,</span> <span class="n">merge_arrays</span>

<span class="kn">from</span> <span class="nn">vemomoto_core.tools.simprofile</span> <span class="kn">import</span> <span class="n">profile</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.tools.hrprint</span> <span class="kn">import</span> <span class="n">HierarchichalPrinter</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.tools.iterext</span> <span class="kn">import</span> <span class="n">Repeater</span><span class="p">,</span> <span class="n">DictIterator</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.tools.tee</span> <span class="kn">import</span> <span class="n">Tee</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.tools.saveobject</span> <span class="kn">import</span> <span class="n">SeparatelySaveable</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.tools.doc_utils</span> <span class="kn">import</span> <span class="n">DocMetaSuperclass</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.concurrent.nicepar</span> <span class="kn">import</span> <span class="n">getCounter</span><span class="p">,</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">Lockable</span><span class="p">,</span> \
    <span class="n">Locked</span><span class="p">,</span> <span class="n">ParallelCounter</span><span class="p">,</span> <span class="n">CircularParallelCounter</span>
<span class="kn">from</span> <span class="nn">vemomoto_core.concurrent.concurrent_futures_ext</span> <span class="kn">import</span> \
    <span class="n">ProcessPoolExecutor</span> <span class="k">as</span> <span class="n">ProcessPoolExecutor_ext</span> 

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.sig_fig_rounding</span> <span class="kn">import</span> <span class="n">RoundToSigFigs_fp</span> <span class="k">as</span> <span class="n">round_rel</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sig_fig_rounding</span> <span class="kn">import</span> <span class="n">RoundToSigFigs_fp</span> <span class="k">as</span> <span class="n">round_rel</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.graph_utils</span> <span class="kn">import</span> <span class="n">find_shortest_distance</span><span class="p">,</span> <span class="n">in_sets</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">graph_utils</span> <span class="kn">import</span> <span class="n">find_shortest_distance</span><span class="p">,</span> <span class="n">in_sets</span>

<span class="c1">#profiling</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">line_profiler</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">teeObject</span> <span class="o">=</span> <span class="n">Tee</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>



<span class="n">CPU_COUNT</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> 
<span class="s2">&quot;Number of CPU cores to be used at most. Defaults to the number of installed cores.&quot;</span>


<div class="viewcode-block" id="FlexibleGraph"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph">[docs]</a><span class="k">class</span> <span class="nc">FlexibleGraph</span><span class="p">(</span><span class="n">HierarchichalPrinter</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Graph with a flexible structure that supports efficient addition and removal</span>
<span class="sd">    of vertices and edges.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edgeData</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">vertexData</span><span class="p">,</span> 
                 <span class="n">replacementMode</span><span class="o">=</span><span class="s2">&quot;overwrite&quot;</span><span class="p">,</span> <span class="n">lengthLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">significanceLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">defaultVertexData</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaultEdgeData</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">printerArgs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construtor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">printerArgs</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="p">((</span><span class="n">edges</span><span class="p">,</span> <span class="n">edgeData</span><span class="p">),</span> 
                          <span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">vertexData</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">prop</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Properties must have the same length &quot;</span> 
                                 <span class="o">+</span> <span class="s2">&quot;as the list of object that they discribe.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">significanceLabel</span> <span class="ow">and</span> 
                <span class="n">significanceLabel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There is no field &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lengthLabel</span><span class="p">)</span> 
                             <span class="o">+</span> <span class="s2">&quot; in the edge data array.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significanceLabel</span> <span class="o">=</span> <span class="n">significanceLabel</span>
        
        <span class="n">overrideExisting</span> <span class="o">=</span> <span class="n">replacementMode</span> <span class="o">==</span> <span class="s2">&quot;override&quot;</span>
        <span class="n">ignoreNew</span> <span class="o">=</span> <span class="n">replacementMode</span> <span class="o">==</span> <span class="s2">&quot;ignore&quot;</span>
        <span class="n">useShortest</span> <span class="o">=</span> <span class="n">replacementMode</span> <span class="o">==</span> <span class="s2">&quot;shortest&quot;</span>
        <span class="n">useLongest</span> <span class="o">=</span> <span class="n">replacementMode</span> <span class="o">==</span> <span class="s2">&quot;longest&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">overrideExisting</span> <span class="ow">or</span> <span class="n">ignoreNew</span> <span class="ow">or</span> <span class="n">useShortest</span> <span class="ow">or</span> <span class="n">useLongest</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;replacementMode not understood. It must be one &quot;</span>
                             <span class="o">+</span> <span class="s2">&quot;of &#39;override&#39;, &#39;ignore&#39;, &#39;shortest&#39;, or &quot;</span>
                             <span class="o">+</span> <span class="s2">&quot;&#39;longest&#39;.&quot;</span><span class="p">)</span>
            
        
        <span class="n">vertexIDs</span> <span class="o">=</span> <span class="n">add_names</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="s2">&quot;ID&quot;</span><span class="p">)</span>
        
        <span class="n">vertexData</span> <span class="o">=</span> <span class="n">rfn</span><span class="o">.</span><span class="n">merge_arrays</span><span class="p">((</span><span class="n">vertexIDs</span><span class="p">,</span> <span class="n">vertexData</span><span class="p">),</span> 
                                      <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">vertexData</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;ID&quot;</span><span class="p">)</span>
        <span class="n">includedVertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        
        <span class="n">vertexData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertexData</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">edgeCount</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="n">useShortest</span> <span class="ow">or</span> <span class="n">useLongest</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lengthLabel</span> <span class="ow">in</span> <span class="n">edgeData</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lengthLabel must match one of the field &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;names of edgeData.&quot;</span><span class="p">)</span>
            <span class="n">lengthArr</span> <span class="o">=</span> <span class="n">edgeData</span><span class="p">[</span><span class="n">lengthLabel</span><span class="p">]</span>
        
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">overwroteSome</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">loopsOccurred</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">loopsOccurred</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">thisVertex</span><span class="p">,</span> <span class="n">otherVertex</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[::</span><span class="n">direction</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vertexDataList</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">vertexIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">vertexData</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> 
                                                  <span class="n">thisVertex</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertexData</span><span class="o">.</span><span class="n">ID</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">==</span> <span class="n">thisVertex</span><span class="p">:</span>
                            <span class="n">vertexIndex</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="n">vertexIndex</span> <span class="o">=</span> <span class="kc">None</span>
                        
                    <span class="n">graph</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexDataList</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertexIndex</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">includedVertices</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="k">if</span> <span class="n">otherVertex</span> <span class="ow">in</span> <span class="n">vertexDataList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">overwroteSome</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">useShortest</span> 
                         <span class="ow">and</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">vertexDataList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">otherVertex</span><span class="p">]]</span> 
                                <span class="o">&gt;</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="n">useLongest</span>
                            <span class="ow">and</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">vertexDataList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">otherVertex</span><span class="p">]]</span> 
                                <span class="o">&lt;</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> 
                        <span class="ow">or</span> <span class="n">overrideExisting</span><span class="p">):</span>
                        
                        <span class="n">vertexDataList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">otherVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
                        <span class="k">if</span> <span class="n">i</span><span class="p">:</span> 
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            
                <span class="n">vertexDataList</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">otherVertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edgeCount</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">overwroteSome</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Some edges occured multiple times. I &quot;</span> 
                          <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;overwrote them.&quot;</span> <span class="k">if</span> <span class="n">overrideExisting</span> <span class="k">else</span> 
                             <span class="p">(</span><span class="s2">&quot;ignored them.&quot;</span> <span class="k">if</span> <span class="n">ignoreNew</span> <span class="k">else</span>
                              <span class="p">(</span><span class="s2">&quot;used the shortest edges.&quot;</span> <span class="k">if</span> <span class="n">useShortest</span> <span class="k">else</span>
                               <span class="p">(</span><span class="s2">&quot;used the longest edges.&quot;</span><span class="p">)))))</span>
        <span class="k">if</span> <span class="n">loopsOccurred</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Some edges were loops. I ignored them.&quot;</span><span class="p">)</span> 
        
        
        <span class="k">for</span> <span class="n">vertexIndex</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">includedVertices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">vertexData</span><span class="o">.</span><span class="n">ID</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertexIndex</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}]</span>
        
        <span class="n">add_names</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;fromID&quot;</span><span class="p">,</span> <span class="s2">&quot;toID&quot;</span><span class="p">))</span>
        <span class="n">from_to</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">vertexData</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">FlexibleArray</span><span class="p">(</span><span class="n">vertexData</span><span class="p">,</span> <span class="n">recArray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">FlexibleArray</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">recArray</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vertexData</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            
        <span class="n">edges</span> <span class="o">=</span> <span class="n">FlexibleArray</span><span class="p">(</span><span class="n">merge_arrays</span><span class="p">((</span><span class="n">from_to</span><span class="p">,</span> <span class="n">edgeData</span><span class="p">)),</span>
                              <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recArray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">defaultVertexData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">defaultVertexData</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">defaultEdgeData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">defaultEdgeData</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgeCount</span> <span class="o">=</span> <span class="n">edgeCount</span>
    
<div class="viewcode-block" id="FlexibleGraph.add_vertex"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.add_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">vertexData</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        
        <span class="k">if</span> <span class="n">vertexID</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;A vertex with the specified ID already exists&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertexData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertexIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertexIndex</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertexData</span><span class="p">)</span>
            <span class="n">vertices</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span><span class="o">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">vertexID</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertexIndex</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{}]</span></div>
        
        
<div class="viewcode-block" id="FlexibleGraph.remove_vertex"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.remove_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#self.increase_print_level()</span>
        <span class="c1">#self.prst(&quot;Removing&quot;, vertexID)</span>
        <span class="k">if</span> <span class="n">counter</span><span class="p">:</span> 
            <span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">successors</span><span class="p">,</span> <span class="n">predecessors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">vertexID</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgeCount</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">successors</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">predecessors</span><span class="p">,</span> <span class="n">successors</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">edges</span><span class="p">[</span><span class="n">graph</span><span class="p">[</span><span class="n">neighbor</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">vertexID</span><span class="p">)]</span></div>
                
        <span class="c1">#self.decrease_print_level()</span>
    
<div class="viewcode-block" id="FlexibleGraph.add_edge"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="p">,</span> <span class="n">edgeData</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">successorDict</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">fromID</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">predecessorDict</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">toID</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">toID</span> <span class="ow">in</span> <span class="n">successorDict</span> <span class="ow">and</span> <span class="n">fromID</span> <span class="ow">in</span> <span class="n">predecessorDict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;The specified edge exists already&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">edgeData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edgeIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="p">,</span> <span class="o">*</span><span class="n">edgeData</span><span class="p">))</span>
        <span class="n">successorDict</span><span class="p">[</span><span class="n">toID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeIndex</span>
        <span class="n">predecessorDict</span><span class="p">[</span><span class="n">fromID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeIndex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgeCount</span> <span class="o">+=</span> <span class="mi">1</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.remove_edge"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.remove_edge">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">successors</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">fromID</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">predecessors</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">toID</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">successors</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">toID</span><span class="p">)]</span>
        <span class="k">del</span> <span class="n">predecessors</span><span class="p">[</span><span class="n">fromID</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edgeCount</span> <span class="o">-=</span> <span class="mi">1</span></div>
    
<div class="viewcode-block" id="FlexibleGraph.set_vertex_data"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.set_vertex_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_vertex_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">vertexInformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span>
        <span class="n">vertexIndex</span> <span class="o">=</span> <span class="n">vertexInformation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="k">if</span> <span class="n">vertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vertexInformation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ID</span><span class="o">=</span><span class="n">vertexID</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span></div>
    
<div class="viewcode-block" id="FlexibleGraph.set_edge_data"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.set_edge_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_edge_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">vertexFromSuccessors</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">fromID</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="n">edgeIndex</span> <span class="o">=</span> <span class="n">vertexFromSuccessors</span><span class="p">[</span><span class="n">toID</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">edgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edgeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fromID</span><span class="o">=</span><span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="o">=</span><span class="n">toID</span><span class="p">)</span>
            <span class="n">vertexFromSuccessors</span><span class="p">[</span><span class="n">toID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeIndex</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">toID</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">fromID</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeIndex</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">edgeIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span></div>
    
<div class="viewcode-block" id="FlexibleGraph.set_default_vertex_data"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.set_default_vertex_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_vertex_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.set_default_edge_data"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.set_default_edge_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_default_edge_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.get_vertex_data"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_vertex_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">vertexInformation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span>
        <span class="n">vertexIndex</span> <span class="o">=</span> <span class="n">vertexInformation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">defaultVertexIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span>
        
        <span class="k">if</span> <span class="n">vertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">defaultVertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Vertex has no specific properties, &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;but no default values are given.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_data</span><span class="p">(</span>
                    <span class="n">vertexID</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">defaultVertexIndex</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexInformation</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertexData</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">defaultVertexIndex</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">vertexData</span><span class="o">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">vertexID</span>
                <span class="k">return</span> <span class="n">vertexData</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
                
<div class="viewcode-block" id="FlexibleGraph.get_edge_data"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_edge_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">vertexFromSuccessors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">fromID</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">edgeIndex</span> <span class="o">=</span> <span class="n">vertexFromSuccessors</span><span class="p">[</span><span class="n">toID</span><span class="p">]</span>
        <span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="k">if</span> <span class="n">edgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">defaultEdgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge has no specific properties, &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;but no default values are given.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_data</span><span class="p">(</span><span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span><span class="p">,</span> 
                                   <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">defaultEdgeIndex</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexFromSuccessors</span><span class="p">[</span><span class="n">toID</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edgeData</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">defaultEdgeIndex</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">edgeData</span><span class="o">.</span><span class="n">fromID</span><span class="p">,</span> <span class="n">edgeData</span><span class="o">.</span><span class="n">toID</span> <span class="o">=</span> <span class="n">fromID</span><span class="p">,</span> <span class="n">toID</span>   
                <span class="k">return</span> <span class="n">edgeData</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">edgeIndex</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">edgeIndex</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="FlexibleGraph.get_edge_count"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_edge_count">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edgeCount</span></div>
    
<div class="viewcode-block" id="FlexibleGraph.get_vertex_count"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_vertex_count">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.get_successors"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_successors">[docs]</a>    <span class="k">def</span> <span class="nf">get_successors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.get_predecessors"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_predecessors">[docs]</a>    <span class="k">def</span> <span class="nf">get_predecessors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.get_neighbor_edges"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.get_neighbor_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbor_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">getSuccessors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">predSuccI</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">getSuccessors</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">getSuccessors</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">neighborDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">][</span><span class="n">predSuccI</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">edgeIndices</span> <span class="o">=</span> <span class="n">neighborDict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultEdgeIndex</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">edgeIndices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeIndices</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">edgeIndices</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">defaultEdgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edge has no specific properties, &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;but no default values are given.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">indexList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">defaultEdgeIndex</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">edgeIndices</span><span class="p">]</span>
                <span class="n">nones</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> 
                          <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighborDict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">indexList</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">fromArr</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">fromID</span>
                <span class="n">toArr</span> <span class="o">=</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">toID</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">nones</span><span class="p">:</span> 
                    <span class="n">fromArr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">toArr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)[::</span><span class="n">order</span><span class="p">]</span>     
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexList</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">edgeIndex</span> <span class="ow">in</span> <span class="n">neighborDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">edgeIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_data</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)[::</span><span class="n">order</span><span class="p">],</span> 
                                           <span class="n">data</span><span class="o">=</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">defaultEdgeIndex</span><span class="p">])</span>
                        <span class="n">indexList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighborDict</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">indexList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edgeIndex</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">indexList</span><span class="p">]</span></div>
            
    
<div class="viewcode-block" id="FlexibleGraph.add_edge_attributes"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.add_edge_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_fields</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FlexibleGraph.add_vertex_attributes"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.add_vertex_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">add_fields</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="FlexibleGraph.remove_insignificant_dead_ends"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlexibleGraph.remove_insignificant_dead_ends">[docs]</a>    <span class="k">def</span> <span class="nf">remove_insignificant_dead_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">significanceLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                       <span class="n">standardSignificant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Removing insignificant dead ends from the graph&quot;</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">allVertexNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">significanceLabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">significanceLabel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">significanceLabel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">significanceLabel</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">significanceLabel</span> <span class="o">=</span> <span class="n">significanceLabel</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">significanceLabel</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">significanceArr</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">significanceLabel</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">significanceLabel</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">significanceArr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">significanceLabel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">significanceLabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">significanceArr</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">significanceLabel</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">significanceArr</span> <span class="o">=</span> <span class="n">Repeater</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">standardSignificant</span> <span class="o">=</span> <span class="n">significanceArr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultVertexIndex</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>
            
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">vertexID</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">vertexID</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
                <span class="n">vertexID</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">successors</span><span class="p">,</span> <span class="n">predecessors</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">continue</span>    
                <span class="k">if</span> <span class="n">vertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">significant</span> <span class="o">=</span> <span class="n">standardSignificant</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">significant</span> <span class="o">=</span> <span class="n">significanceArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                        <span class="n">significant</span> <span class="o">=</span> <span class="n">standardSignificant</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">significant</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">successors</span><span class="p">):</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">extendleft</span><span class="p">(</span><span class="n">predecessors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span> 
                          <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">successors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> 
                              <span class="ow">and</span> <span class="n">predecessors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">successors</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">extendleft</span><span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">vertexID</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Removed </span><span class="si">{}</span><span class="s2"> out of </span><span class="si">{}</span><span class="s2"> vertices (&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                                       <span class="n">allVertexNumber</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">counter</span><span class="o">.</span><span class="n">index</span> <span class="o">/</span> <span class="n">allVertexNumber</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div></div>
    
        
<div class="viewcode-block" id="FastGraph"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph">[docs]</a><span class="k">class</span> <span class="nc">FastGraph</span><span class="p">(</span><span class="n">SeparatelySaveable</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">DocMetaSuperclass</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
        
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flexibleGraph</span><span class="p">):</span>
        
        <span class="n">SeparatelySaveable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;.rn&#39;</span><span class="p">)</span>
        
        <span class="c1">#can leave vertexIDs as iterator???</span>
        <span class="n">rawVertexData</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">flexibleGraph</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">significanceLabel</span> <span class="o">=</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">significanceLabel</span>
        
        <span class="n">translateVertices</span> <span class="o">=</span> <span class="p">{</span><span class="n">vertexID</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">index</span> 
                             <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">vertexID</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rawVertexData</span><span class="p">)}</span>
        
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rawVertexData</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">,</span>
                                                             <span class="s2">&quot;successors&quot;</span><span class="p">],</span>
                                                   <span class="s2">&quot;formats&quot;</span><span class="p">:[</span><span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">]})</span>
        
        <span class="n">oldVertexData</span> <span class="o">=</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span>
        <span class="n">oldEdgeData</span> <span class="o">=</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span>
        <span class="n">vertexData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rawVertexData</span><span class="p">),</span> 
                              <span class="n">dtype</span><span class="o">=</span><span class="n">flexibleGraph</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flexibleGraph</span><span class="o">.</span><span class="n">get_edge_count</span><span class="p">(),</span> 
                         <span class="n">dtype</span><span class="o">=</span><span class="n">flexibleGraph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span> 
                                <span class="o">+</span> <span class="p">[(</span><span class="s2">&quot;fromIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;toIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)])</span>
        
        <span class="n">edgeFromIDArr</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;fromID&quot;</span><span class="p">]</span>
        <span class="n">edgeToIDArr</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;toID&quot;</span><span class="p">]</span>
        <span class="n">edgeFromIndexArr</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;fromIndex&quot;</span><span class="p">]</span>
        <span class="n">edgeToIndexArr</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">]</span>
        
        <span class="n">edgesViewOld</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">flexibleGraph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">defaultVertexIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hasDefaultVertexData</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hasDefaultVertexData</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">defaultVertexData</span> <span class="o">=</span> <span class="n">oldVertexData</span><span class="p">[</span><span class="n">flexibleGraph</span><span class="o">.</span><span class="n">defaultVertexIndex</span><span class="p">]</span>
        
        <span class="n">defaultEdgeIndex</span> <span class="o">=</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">defaultEdgeIndex</span>
        
        <span class="n">toBeAddedPredecessors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edgeBlockIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rawVertexData</span><span class="p">):</span>
            <span class="n">vertexID</span><span class="p">,</span> <span class="n">vertexDataRecord</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="n">vertexDataRecord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">hasDefaultVertexData</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Some vertices have missing information &quot;</span>
                                     <span class="o">+</span> <span class="s2">&quot;and no default data are given&quot;</span><span class="p">)</span>
                <span class="n">vertexData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultVertexData</span>
                <span class="n">vertexData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">vertexID</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertexData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldVertexData</span><span class="p">[</span><span class="n">vertexDataRecord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            
            <span class="n">successorIndices</span> <span class="o">=</span> <span class="p">[</span><span class="n">translateVertices</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]</span> <span class="k">for</span> <span class="n">vertexID</span> <span class="ow">in</span> 
                                <span class="n">vertexDataRecord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                
            <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> 
                    <span class="n">vertexIndex</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">edgeBlockIndex</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">vertexIndex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">successorIndices</span><span class="p">)</span>
                    <span class="p">}</span>
            
            <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            
            <span class="n">toBeAddedPredecessors</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">edgeBlockIndex</span><span class="o">+</span><span class="n">j</span><span class="p">))</span> 
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertexDataRecord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
            
            <span class="n">indexList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">defaultEdgeIndex</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">vertexDataRecord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            
            <span class="n">nones</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> 
                      <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertexDataRecord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">edgesViewOld</span><span class="p">[</span><span class="n">edgeBlockIndex</span><span class="p">:</span><span class="n">edgeBlockIndex</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">indexList</span><span class="p">)]</span> <span class="o">=</span> \
                        <span class="n">oldEdgeData</span><span class="p">[</span><span class="n">indexList</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> 
                <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">indexList</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Some edges have missing information &quot;</span>
                                         <span class="o">+</span> <span class="s2">&quot;and no default data are given&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
            
            <span class="n">edgeFromIndexArr</span><span class="p">[</span><span class="n">edgeBlockIndex</span><span class="p">:</span><span class="n">edgeBlockIndex</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">indexList</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span> 
            <span class="n">edgeToIndexArr</span><span class="p">[</span><span class="n">edgeBlockIndex</span><span class="p">:</span><span class="n">edgeBlockIndex</span>
                                            <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexList</span><span class="p">)]</span> <span class="o">=</span> <span class="n">successorIndices</span>
                     
            
            
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">nones</span><span class="p">:</span> 
                <span class="n">edgeFromIDArr</span><span class="p">[</span><span class="n">edgeBlockIndex</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertexID</span>  
                <span class="n">edgeToIDArr</span><span class="p">[</span><span class="n">edgeBlockIndex</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span>
            
            <span class="n">edgeBlockIndex</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexList</span><span class="p">)</span>
                
        <span class="k">for</span> <span class="n">vertexID</span><span class="p">,</span> <span class="n">predecessorData</span> <span class="ow">in</span> <span class="n">toBeAddedPredecessors</span><span class="p">:</span>
            <span class="n">neighbors</span><span class="p">[</span><span class="n">translateVertices</span><span class="p">[</span><span class="n">vertexID</span><span class="p">]][</span><span class="s2">&quot;predecessors&quot;</span>
                               <span class="p">][</span><span class="n">predecessorData</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">predecessorData</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       
        
        
        <span class="n">mergeArr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">vertexData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="n">dtype</span><span class="o">=</span><span class="n">vertexData</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="o">+</span><span class="n">neighbors</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
         
        <span class="n">view</span> <span class="o">=</span> <span class="n">fields_view</span><span class="p">(</span><span class="n">mergeArr</span><span class="p">,</span> <span class="n">vertexData</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="n">view</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vertexData</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">fields_view</span><span class="p">(</span><span class="n">mergeArr</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="n">view</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">neighbors</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">FlexibleArray</span><span class="p">(</span><span class="n">mergeArr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">FlexibleArray</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_save_separately</span><span class="p">(</span><span class="s1">&#39;vertices&#39;</span><span class="p">,</span> <span class="s1">&#39;edges&#39;</span><span class="p">)</span>
        
    
    <span class="c1"># this method is not needed.</span>
<div class="viewcode-block" id="FastGraph.make_edges_contiguous"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.make_edges_contiguous">[docs]</a>    <span class="k">def</span> <span class="nf">make_edges_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">newEdgeIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">make_contiguous</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">newEdgeIndices</span><span class="p">):</span> 
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">cut</span><span class="p">()</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">edgeArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span>
        
        <span class="k">for</span> <span class="n">indexName</span><span class="p">,</span> <span class="n">oppositeIndexName</span><span class="p">,</span> <span class="n">neighborName</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;fromIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;toIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;successors&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;toIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;fromIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;predecessors&quot;</span><span class="p">)):</span>
        
            <span class="n">neighborVertices</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="n">newEdgeIndices</span><span class="p">][</span><span class="n">indexName</span><span class="p">]</span>
            <span class="n">oppositeNeighborVertices</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="n">newEdgeIndices</span><span class="p">][</span>
                                                            <span class="n">oppositeIndexName</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">oppositeNeighbor</span><span class="p">,</span> <span class="n">newEdgeIndex</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">neighborName</span><span class="p">][</span><span class="n">neighborVertices</span><span class="p">],</span>
                    <span class="n">oppositeNeighborVertices</span><span class="p">,</span>
                    <span class="n">newEdgeIndices</span><span class="p">):</span>
                <span class="n">neighbors</span><span class="p">[</span><span class="n">oppositeNeighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newEdgeIndex</span></div>
                
        
<div class="viewcode-block" id="FastGraph.add_vertex"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.add_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexData</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertexData</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FastGraph.remove_vertex"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.remove_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexIndex</span><span class="p">):</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="n">vertexData</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
        <span class="n">predSuccEssors</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;successors&quot;</span><span class="p">,</span> <span class="s2">&quot;predecessors&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predSuccEssors</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">vertexData</span><span class="p">[</span><span class="n">predSuccEssors</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="n">edges</span><span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">neighbor</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">vertexIndex</span><span class="p">)]</span>
        <span class="k">del</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span></div>
            
<div class="viewcode-block" id="FastGraph.add_edge"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromIndex</span><span class="p">,</span> <span class="n">toIndex</span><span class="p">,</span> <span class="n">edgeData</span><span class="p">):</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertices</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fromIndex</span><span class="p">,</span> <span class="n">toIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;One of the given vertices &quot;</span> <span class="o">+</span> 
                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> and </span><span class="si">{1}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fromIndex</span><span class="p">,</span> <span class="n">toIndex</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">toIndex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The specified edge exists already&quot;</span><span class="p">)</span>
        <span class="n">edgeID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edgeData</span><span class="p">)</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="p">[</span><span class="n">toIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeID</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">toIndex</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeID</span></div>
    
<div class="viewcode-block" id="FastGraph.remove_edge"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.remove_edge">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromIndex</span><span class="p">,</span> <span class="n">toIndex</span><span class="p">):</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">toIndex</span><span class="p">)]</span>
        <span class="k">del</span> <span class="n">vertices</span><span class="p">[</span><span class="n">toIndex</span><span class="p">]</span><span class="o">.</span><span class="n">predecessors</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="FastGraph.add_edge_attributes"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.add_edge_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_fields</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FastGraph.add_vertex_attributes"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FastGraph.add_vertex_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">add_fields</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span> <span class="n">fillVal</span><span class="p">)</span></div></div>
        
    
<div class="viewcode-block" id="FlowPointGraph"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlowPointGraph">[docs]</a><span class="k">class</span> <span class="nc">FlowPointGraph</span><span class="p">(</span><span class="n">FastGraph</span><span class="p">,</span> <span class="n">HierarchichalPrinter</span><span class="p">,</span> <span class="n">Lockable</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flexibleGraph</span><span class="p">,</span> <span class="n">lengthLabel</span><span class="p">,</span> 
                 <span class="n">significanceLabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">printerArgs</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FastGraph.__init__(flexibleGraph)    </span>
<span class="sd">        HierarchichalPrinter.__init__(self, **printerArgs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FastGraph</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flexibleGraph</span><span class="o">=</span><span class="n">flexibleGraph</span><span class="p">)</span>
        <span class="n">HierarchichalPrinter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">printerArgs</span><span class="p">)</span>
        <span class="n">Lockable</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">significanceLabel</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">significanceLabel</span><span class="p">:</span>
                <span class="n">significanceLabel</span> <span class="o">=</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">significanceLabel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A significance label must be given either by &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;the flexible graph input or explicitely in &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot; FlowPointGraph&#39;s constructor.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">significanceLabel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There is no field &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">significanceLabel</span><span class="p">)</span> 
                             <span class="o">+</span> <span class="s2">&quot; in the vertex data array.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">significanceLabel</span> <span class="o">==</span> <span class="s2">&quot;significant&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;significant&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The vertex data array must not contain a &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;field &#39;significant&#39;, if &#39;significant&#39; is &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;not the significance label.&quot;</span><span class="p">)</span>
            <span class="n">add_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">significanceLabel</span><span class="p">,</span> <span class="s2">&quot;significant&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">lengthLabel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There is no field &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lengthLabel</span><span class="p">)</span> 
                             <span class="o">+</span> <span class="s2">&quot; in the edge data array.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lengthLabel</span> <span class="o">==</span> <span class="s2">&quot;length&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;length&quot;</span> <span class="ow">in</span> <span class="n">flexibleGraph</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The edge data array must not contain a field &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;&#39;length&#39;, if &#39;length&#39; is not the length &quot;</span>
                                 <span class="o">+</span> <span class="s2">&quot;label.&quot;</span><span class="p">)</span>
            <span class="n">add_alias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">lengthLabel</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">)</span>
        
    
<div class="viewcode-block" id="FlowPointGraph.preprocessing"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlowPointGraph.preprocessing">[docs]</a>    <span class="k">def</span> <span class="nf">preprocessing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialBound</span><span class="p">,</span> <span class="n">boundFactor</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pruneFactor</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
                      <span class="n">additionalBoundFactor</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">expansionBounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                      <span class="n">degreeBound</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxEdgeLength</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">expansionBounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expansionBounds</span> <span class="o">=</span> <span class="n">Repeater</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expansionBounds</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>
            <span class="n">expansionBounds</span> <span class="o">=</span> <span class="n">iterchain</span><span class="p">(</span><span class="n">expansionBounds</span><span class="p">,</span> 
                                        <span class="n">Repeater</span><span class="p">(</span><span class="n">expansionBounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Preprocessing the graph...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;initialBound:&quot;</span><span class="p">,</span> <span class="n">initialBound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;boundFactor:&quot;</span><span class="p">,</span> <span class="n">boundFactor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;pruneFactor:&quot;</span><span class="p">,</span> <span class="n">pruneFactor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;additionalBoundFactor:&quot;</span><span class="p">,</span> <span class="n">additionalBoundFactor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;expansionBounds:&quot;</span><span class="p">,</span> <span class="n">expansionBounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;degreeBound:&quot;</span><span class="p">,</span> <span class="n">degreeBound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;maxEdgeLength:&quot;</span><span class="p">,</span> <span class="n">maxEdgeLength</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pruneFactor</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The pruneFactor must be at least 2.&quot;</span><span class="p">)</span>
        
        <span class="n">temporaryEdgesFields</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">,</span> <span class="s2">&quot;considered&quot;</span><span class="p">]</span>
        
        <span class="n">edges</span><span class="o">.</span><span class="n">add_fields</span><span class="p">(</span><span class="n">temporaryEdgesFields</span> 
                         <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;originalEdge1&quot;</span><span class="p">,</span> <span class="s2">&quot;originalEdge2&quot;</span><span class="p">],</span>
                         <span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">temporaryVerticesFields</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tmp_predecessors&quot;</span><span class="p">,</span> <span class="s2">&quot;tmp_successors&quot;</span><span class="p">,</span> 
                                   <span class="s2">&quot;inPenalty&quot;</span><span class="p">,</span> <span class="s2">&quot;outPenalty&quot;</span><span class="p">,</span> 
                                   <span class="s2">&quot;inPenalty_original&quot;</span><span class="p">,</span> <span class="s2">&quot;unbounded&quot;</span><span class="p">]</span>
        
        <span class="c1"># the graph G&#39;</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">add_fields</span><span class="p">([</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">temporaryVerticesFields</span><span class="p">,</span> 
                            <span class="p">[</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> 
                             <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]),</span> 
                             <span class="n">deepcopy</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                             <span class="n">vertices</span><span class="o">.</span><span class="n">considered</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;posix&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Parallelization with shared memory is ony possible &quot;</span>
                          <span class="o">+</span> <span class="s2">&quot;on Unix-based systems. Thus, the code will not be &quot;</span>
                          <span class="o">+</span> <span class="s2">&quot;executed in parallel.&quot;</span><span class="p">)</span>
        
        <span class="n">vertexArr</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[:</span><span class="n">vertices</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">tmp_predecessorsArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;tmp_predecessors&quot;</span><span class="p">]</span>
        <span class="n">tmp_successorsArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;tmp_successors&quot;</span><span class="p">]</span>
        <span class="n">inPenaltyArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty_original&quot;</span><span class="p">]</span>
        <span class="n">outPenaltyArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;outPenalty&quot;</span><span class="p">]</span>
        <span class="n">totalVertexNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        
        <span class="n">bound</span> <span class="o">=</span> <span class="n">initialBound</span>
        <span class="n">changeIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">edgeSize</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span>
        
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># break statement, if all edges are bounded</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Computing reach bounds smaller than&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span> <span class="o">==</span> <span class="n">changeIndex</span> 
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">edgeSize</span> <span class="o">==</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">edgeArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[:</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
                <span class="n">edgeConsideredArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">considered</span><span class="p">[:</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
                <span class="n">changeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span>
                <span class="n">edgeSize</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span>
            
            <span class="c1"># we do not have to process vertices that do not have successors.</span>
            <span class="c1"># trees rooting there will consist of the root only.</span>
            <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">],</span>  
                                                    <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;tmp_successors&quot;</span><span class="p">])</span>
            
            
            <span class="n">consideredVertexIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_bypass_vertices</span><span class="p">(</span><span class="n">consideredVertexIndices</span><span class="p">,</span> 
                                   <span class="n">bound</span><span class="p">,</span> <span class="n">expansionBounds</span><span class="o">.</span><span class="fm">__next__</span><span class="p">(),</span> 
                                   <span class="n">degreeBound</span><span class="p">,</span> <span class="n">maxEdgeLength</span><span class="p">)</span>
            
            <span class="n">deletedVerticesNumber</span> <span class="o">=</span> <span class="p">(</span><span class="n">totalVertexNumber</span> 
                                     <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">deletedVerticesNumber</span><span class="p">,</span> <span class="s2">&quot;out of&quot;</span><span class="p">,</span> <span class="n">totalVertexNumber</span><span class="p">,</span> 
                      <span class="s2">&quot;vertices have been removed (</span><span class="si">{:6.2%}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                      <span class="n">deletedVerticesNumber</span><span class="o">/</span><span class="n">totalVertexNumber</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span> <span class="o">==</span> <span class="n">changeIndex</span> 
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">edgeSize</span> <span class="o">==</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">edgeArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[:</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
                <span class="n">edgeConsideredArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">considered</span><span class="p">[:</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
                <span class="n">changeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span>
                <span class="n">edgeSize</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span>
            
            <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inPenaltyArr</span> 
            
            <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="o">.</span><span class="n">at</span><span class="p">(</span>
                <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty&quot;</span><span class="p">],</span> 
                <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">][</span><span class="n">edgeConsideredArr</span><span class="p">],</span>
                <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">edgeConsideredArr</span><span class="p">]</span>
                        <span class="p">)</span>
            
            
            <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> 
                                                        <span class="p">(</span><span class="n">pruneFactor</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">bound</span><span class="p">],</span>
                                            <span class="p">[</span><span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty_original&quot;</span><span class="p">]],</span> 
                                            <span class="n">bound</span><span class="p">)</span>
            
            
            <span class="n">consideredVertexIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">counter</span> <span class="o">=</span> <span class="n">getCounter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">consideredVertexIndices</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
            
            <span class="n">pruneConstant</span> <span class="o">=</span> <span class="n">bound</span><span class="o">*</span><span class="n">pruneFactor</span>
            
            <span class="n">wrappedFunc</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_reach_bounds_starting_from</span><span class="p">,</span>
                                  <span class="n">bound</span><span class="o">=</span><span class="n">bound</span><span class="p">,</span> 
                                  <span class="n">additionalBoundFactor</span><span class="o">=</span><span class="n">additionalBoundFactor</span><span class="p">,</span>
                                  <span class="n">pruneConstant</span><span class="o">=</span><span class="n">pruneConstant</span><span class="p">,</span>
                                  <span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>
            
            <span class="n">lengths</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">]]</span>
            
            <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">][</span><span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                                    <span class="p">(</span><span class="n">lengths</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">,),</span> <span class="p">(</span><span class="n">lengths</span><span class="p">,),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,)</span>
                                                               <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;posix&#39;</span><span class="p">:</span> <span class="c1">#and bound &lt; 26</span>
                
                <span class="n">edges</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sharedmem</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">),</span> 
                                           <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">sharedmem</span><span class="o">.</span><span class="n">MapReduce</span><span class="p">(</span><span class="n">np</span><span class="o">=</span><span class="n">CPU_COUNT</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">wrappedFunc</span><span class="p">,</span> <span class="n">consideredVertexIndices</span><span class="p">)</span>
                    
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">wrappedFunc</span><span class="p">,</span> <span class="n">consideredVertexIndices</span><span class="p">))</span>
            
            <span class="n">edgeArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[:</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">edgeConsideredArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">considered</span><span class="p">[:</span><span class="n">edges</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">changeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span>
            <span class="n">edgeSize</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
            
            <span class="c1"># Delete edges with bounded reach and add penalties</span>
            
            <span class="n">toBeDeleted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> 
                                <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">]</span>
                                                        <span class="p">),</span> 
                                         <span class="n">edgeConsideredArr</span><span class="p">)</span>
            
            <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">][</span><span class="n">toBeDeleted</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="n">totalEdgeNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgeArr</span><span class="p">)</span>
            <span class="n">boundedEdgesNumber</span> <span class="o">=</span> <span class="n">totalEdgeNumber</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">boundedEdgesNumber</span><span class="p">,</span> <span class="s2">&quot;edge reaches out of&quot;</span><span class="p">,</span> 
                      <span class="n">totalEdgeNumber</span><span class="p">,</span> <span class="s2">&quot;are bounded (&quot;</span> <span class="o">+</span> 
                      <span class="s2">&quot;</span><span class="si">{:6.2%}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">boundedEdgesNumber</span><span class="o">/</span><span class="n">totalEdgeNumber</span><span class="p">)</span> 
                      <span class="o">+</span> <span class="s2">&quot;).&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="c1"># break statement for loop</span>
                <span class="k">break</span>
            
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edgeArr</span><span class="p">[</span><span class="n">toBeDeleted</span><span class="p">]:</span>
                <span class="n">fromIndex</span><span class="p">,</span> <span class="n">toIndex</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;fromIndex&quot;</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">tmp_predecessorsArr</span><span class="p">[</span><span class="n">toIndex</span><span class="p">][</span><span class="n">fromIndex</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">tmp_successorsArr</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">][</span><span class="n">toIndex</span><span class="p">]</span>
                
                <span class="c1"># add penalties</span>
                <span class="k">if</span> <span class="n">outPenaltyArr</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]:</span>
                    <span class="n">outPenaltyArr</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">inPenaltyArr</span><span class="p">[</span><span class="n">toIndex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]:</span>
                    <span class="n">inPenaltyArr</span><span class="p">[</span><span class="n">toIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
            
            <span class="n">bound</span> <span class="o">*=</span> <span class="n">boundFactor</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_edge_reaches_to_vertex_reaches</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">remove_fields</span><span class="p">(</span><span class="n">temporaryVerticesFields</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">remove_fields</span><span class="p">(</span><span class="n">temporaryEdgesFields</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_sort_neighbors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">cut</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span></div>
        
        
    <span class="k">def</span> <span class="nf">_get_reach_bounds_starting_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rootIndex</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> 
                                         <span class="n">additionalBoundFactor</span><span class="p">,</span>
                                         <span class="n">pruneConstant</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                         <span class="n">counter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">counter</span><span class="p">:</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">percentage</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentage</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">rTol</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1e-7</span>
        <span class="n">increasedBound</span> <span class="o">=</span> <span class="n">bound</span> <span class="o">*</span> <span class="n">additionalBoundFactor</span>
        <span class="n">successorArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;tmp_successors&quot;</span><span class="p">]</span>
        <span class="n">costArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        <span class="n">inPenaltyArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;inPenalty&quot;</span><span class="p">]</span>
        <span class="n">outPenaltyArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;outPenalty&quot;</span><span class="p">]</span>
        <span class="n">reachBoundArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
        
        <span class="n">tree</span> <span class="o">=</span> <span class="n">FlexibleArrayDict</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> 
                                 <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;vertexIndex&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> 
                                                 <span class="s2">&quot;parentMinHeight&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> 
                                                 <span class="s2">&quot;extension&quot;</span><span class="p">,</span> <span class="s2">&quot;xCost&quot;</span><span class="p">,</span> 
                                                 <span class="s2">&quot;successors&quot;</span><span class="p">,</span> <span class="s2">&quot;visited&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;relevant&quot;</span><span class="p">,</span> 
                                                 <span class="s2">&quot;improvableInnerVertex&quot;</span><span class="p">],</span>
                                      <span class="s2">&quot;formats&quot;</span><span class="p">:[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;object&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">]})</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">setitem_by_keywords</span><span class="p">(</span><span class="n">rootIndex</span><span class="p">,</span> <span class="n">vertexIndex</span><span class="o">=</span><span class="n">rootIndex</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                                 <span class="n">successors</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">relevant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">queue</span> <span class="o">=</span> <span class="n">intquickheapdict</span><span class="p">()</span>
        <span class="n">rootPenalty</span> <span class="o">=</span> <span class="n">inPenaltyArr</span><span class="p">[</span><span class="n">rootIndex</span><span class="p">]</span>
        <span class="n">queue</span><span class="p">[</span><span class="n">rootIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootPenalty</span>
        
        <span class="n">boundableEdges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">relevantCount</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># grow the tree</span>
        
        <span class="k">while</span> <span class="n">relevantCount</span><span class="p">:</span>
            <span class="n">vertex</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">cost</span><span class="o">-</span><span class="n">rootPenalty</span> <span class="o">&gt;</span> <span class="n">pruneConstant</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="k">break</span>
            
            <span class="n">vertexIndexInTree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">indexDict</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
            <span class="n">vertexData</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
            <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
            
            <span class="c1"># add vertex as successor of parent</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">]</span>
                       <span class="p">][</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertexIndexInTree</span><span class="p">)</span>
            
            <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;improvableInnerVertex&quot;</span><span class="p">]:</span>
                <span class="n">boundableEdges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">vertexIndexInTree</span><span class="p">,</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;edge&quot;</span><span class="p">]))</span>
            
            <span class="c1"># for the successors of vertex, vertex is the parent</span>
            <span class="n">parentIndexInTree</span> <span class="o">=</span> <span class="n">vertexIndexInTree</span>
            <span class="n">parentextension</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;extension&quot;</span><span class="p">]</span>
            <span class="n">xCost</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;xCost&quot;</span><span class="p">]</span>
            <span class="n">parentInPenalty</span> <span class="o">=</span> <span class="n">inPenaltyArr</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
            <span class="n">parentOutPenalty</span> <span class="o">=</span> <span class="n">outPenaltyArr</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>
            <span class="n">parentRelevant</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;relevant&quot;</span><span class="p">]</span>
            <span class="n">parentCost</span> <span class="o">=</span> <span class="n">cost</span>
            <span class="n">depthParentSmallerInPenaltyParent</span> <span class="o">=</span> \
                                    <span class="n">parentCost</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span> <span class="n">parentInPenalty</span>
            
            <span class="k">if</span> <span class="n">parentRelevant</span><span class="p">:</span>
                <span class="n">relevantCount</span> <span class="o">-=</span> <span class="mi">1</span>
            
            <span class="k">for</span> <span class="n">successor</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">successorArr</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">edgeCost</span> <span class="o">=</span> <span class="n">costArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
                <span class="n">newCost</span> <span class="o">=</span> <span class="n">parentCost</span> <span class="o">+</span> <span class="n">edgeCost</span>
                
                <span class="k">if</span> <span class="n">successor</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
                    <span class="n">successorCost</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="n">successor</span><span class="p">]</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="n">successorCost</span> <span class="o">&gt;</span> <span class="n">newCost</span> <span class="o">*</span> <span class="n">rTol</span> <span class="c1">#+ tolerance</span>
                <span class="k">else</span><span class="p">:</span>    <span class="c1"># if the vertex is not in the queue, </span>
                                    <span class="c1"># it either has been removed or its </span>
                                    <span class="c1"># value is infinity</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">successor</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
                        <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">tree</span><span class="o">.</span><span class="n">setitem_by_keywords</span><span class="p">(</span><span class="n">successor</span><span class="p">,</span> 
                                                 <span class="n">vertexIndex</span><span class="o">=</span><span class="n">successor</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="n">update</span> <span class="o">=</span> <span class="kc">False</span>
                
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                    <span class="c1"># put vertex in queue / update it</span>
                    <span class="n">queue</span><span class="p">[</span><span class="n">successor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newCost</span>
                    <span class="n">newVertexData</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">successor</span><span class="p">]</span>
                    <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parentIndexInTree</span>
                    
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">parentIndexInTree</span><span class="p">:</span>
                        <span class="n">xCost</span> <span class="o">=</span> <span class="n">newCost</span><span class="o">-</span><span class="n">inPenaltyArr</span><span class="p">[</span><span class="n">successor</span><span class="p">]</span>
                    
                    <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;xCost&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xCost</span>
                    <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
                    
                    <span class="c1"># check relevance of the vertex and include it in the </span>
                    <span class="c1"># queue, if necessary</span>
                    
                    <span class="c1"># 1.: Check whether inner vertex</span>
                    <span class="n">innerVertex</span> <span class="o">=</span>  <span class="p">(</span><span class="ow">not</span> <span class="n">parentIndexInTree</span> <span class="ow">or</span>
                                    <span class="p">((</span><span class="n">newCost</span><span class="o">-</span><span class="n">xCost</span><span class="p">)</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span> <span class="n">bound</span> 
                                     <span class="ow">and</span> <span class="ow">not</span> <span class="n">depthParentSmallerInPenaltyParent</span><span class="p">))</span>
                    
                    <span class="c1"># calculate extension</span>
                    <span class="c1"># check whether improvable</span>
                    <span class="k">with</span> <span class="n">Locked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                        <span class="n">edgeReachBound</span> <span class="o">=</span> <span class="n">reachBoundArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">newCost</span> <span class="o">&gt;</span> <span class="n">edgeReachBound</span><span class="o">*</span><span class="n">rTol</span> <span class="ow">and</span> <span class="n">innerVertex</span><span class="p">:</span>
                        <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;extension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgeCost</span>
                        <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;improvableInnerVertex&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;extension&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parentextension</span> <span class="o">+</span> <span class="n">edgeCost</span>
                    
                    <span class="c1"># 2. check all relevance criteria</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">innerVertex</span>
                            <span class="ow">or</span> <span class="p">(</span><span class="n">parentRelevant</span> 
                                <span class="ow">and</span> <span class="p">(</span><span class="n">parentextension</span><span class="o">+</span><span class="n">parentOutPenalty</span><span class="p">)</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span> <span class="n">bound</span>
                                <span class="ow">and</span> <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;extension&quot;</span><span class="p">]</span>
                                        <span class="o">+</span> <span class="n">outPenaltyArr</span><span class="p">[</span><span class="n">successor</span><span class="p">]</span> 
                                                            <span class="o">&lt;=</span> <span class="n">increasedBound</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;relevant&quot;</span><span class="p">]:</span>
                            <span class="n">relevantCount</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;relevant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;relevant&quot;</span><span class="p">]:</span>
                        <span class="n">relevantCount</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">newVertexData</span><span class="p">[</span><span class="s2">&quot;relevant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="n">treeArr</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">array</span>
                    
        <span class="c1"># process leafs that have not been extended</span>
        <span class="k">for</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">depth</span> <span class="ow">in</span> <span class="n">queue</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">leafIndexInTree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">indexDict</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
            <span class="n">leafData</span> <span class="o">=</span> <span class="n">treeArr</span><span class="p">[</span><span class="n">leafIndexInTree</span><span class="p">]</span>
            <span class="n">leafData</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="n">treeArr</span><span class="p">[</span><span class="n">leafData</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">]][</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">leafIndexInTree</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">leafData</span><span class="p">[</span><span class="s2">&quot;improvableInnerVertex&quot;</span><span class="p">]:</span>
                <span class="n">boundableEdges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">leafIndexInTree</span><span class="p">,</span> <span class="n">leafData</span><span class="p">[</span><span class="s2">&quot;edge&quot;</span><span class="p">]))</span>
        
        
        <span class="c1"># compute height of elements in tree. Thereby, assign to each vertex</span>
        <span class="c1"># the height of its parent, if it would be reached through this vertex</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">vertexData</span> <span class="o">=</span> <span class="n">treeArr</span><span class="p">[</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;visited&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]:</span>
                <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;visited&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">parentData</span> <span class="o">=</span> <span class="n">treeArr</span><span class="p">[</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">]]</span>
                <span class="n">newHeight</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;parentMinHeight&quot;</span><span class="p">],</span> 
                                 <span class="n">outPenaltyArr</span><span class="p">[</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;vertexIndex&quot;</span><span class="p">]])</span> 
                             <span class="o">+</span> <span class="n">costArr</span><span class="p">[</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;edge&quot;</span><span class="p">]])</span>
                
                <span class="c1"># change the own height to the height of the parent, if it </span>
                <span class="c1"># would be reached through the vertex</span>
                <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;parentMinHeight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newHeight</span>
                
                <span class="c1"># change the real height of the parent</span>
                <span class="c1"># (now parentMinHeight contains the real height, not the </span>
                <span class="c1">#  parent&#39;s - this will be changed later - see above)</span>
                <span class="k">if</span> <span class="n">parentData</span><span class="p">[</span><span class="s2">&quot;parentMinHeight&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span> <span class="n">newHeight</span><span class="p">:</span>
                    <span class="n">parentData</span><span class="p">[</span><span class="s2">&quot;parentMinHeight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newHeight</span>
        
        <span class="n">depthArray</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;depth&quot;</span><span class="p">]</span>
        <span class="n">heightArray</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;parentMinHeight&quot;</span><span class="p">]</span>
                
        <span class="k">for</span> <span class="n">successorIndexInTree</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">boundableEdges</span><span class="p">:</span>
            <span class="n">newReachBound</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">depthArray</span><span class="p">[</span><span class="n">successorIndexInTree</span><span class="p">],</span>
                                <span class="n">heightArray</span><span class="p">[</span><span class="n">successorIndexInTree</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">newReachBound</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&gt;=</span> <span class="n">bound</span><span class="p">:</span>
                <span class="n">newReachBound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">with</span> <span class="n">Locked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">newReachBound</span> <span class="o">&gt;</span> <span class="n">reachBoundArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                    <span class="n">reachBoundArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">newReachBound</span>
    
    <span class="k">def</span> <span class="nf">_bypass_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexIndices</span><span class="p">,</span> <span class="n">reachBound</span><span class="p">,</span> 
                          <span class="n">expansionBound</span><span class="p">,</span> <span class="n">degreeBound</span><span class="p">,</span> <span class="n">maxEdgeLength</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Determining vertex weights.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">ParallelCounter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertexIndices</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
        
        <span class="n">wrappedFunc</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_determine_vertex_weight</span><span class="p">,</span> 
                              <span class="n">reachBound</span><span class="o">=</span><span class="n">reachBound</span><span class="p">,</span>
                              <span class="n">expansionBound</span><span class="o">=</span><span class="n">expansionBound</span><span class="p">,</span> 
                              <span class="n">degreeBound</span><span class="o">=</span><span class="n">degreeBound</span><span class="p">,</span>
                              <span class="n">maxEdgeLength</span><span class="o">=</span><span class="n">maxEdgeLength</span><span class="p">,</span>
                              <span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;posix&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">sharedmem</span><span class="o">.</span><span class="n">MapReduce</span><span class="p">(</span><span class="n">np</span><span class="o">=</span><span class="n">CPU_COUNT</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">vertexWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">wrappedFunc</span><span class="p">,</span> <span class="n">vertexIndices</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertexWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">wrappedFunc</span><span class="p">,</span> <span class="n">vertexIndices</span><span class="p">)))</span>
        
        <span class="n">considered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vertexWeights</span><span class="p">))</span>
        
        <span class="n">vertexWeights</span> <span class="o">=</span> <span class="n">intquickheapdict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">vertexIndices</span><span class="p">[</span><span class="n">considered</span><span class="p">],</span> 
                                          <span class="n">vertexWeights</span><span class="p">[</span><span class="n">considered</span><span class="p">]),</span> 
                                         <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Bypassing vertices&quot;</span><span class="p">)</span>       
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">dictIterator</span> <span class="o">=</span> <span class="n">DictIterator</span><span class="p">(</span><span class="n">vertexWeights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bypass_vertex</span><span class="p">,</span> 
                        <span class="n">reachBound</span><span class="o">=</span><span class="n">reachBound</span><span class="p">,</span>
                        <span class="n">expansionBound</span><span class="o">=</span><span class="n">expansionBound</span><span class="p">,</span> 
                        <span class="n">degreeBound</span><span class="o">=</span><span class="n">degreeBound</span><span class="p">,</span> 
                        <span class="n">vertexWeights</span><span class="o">=</span><span class="n">vertexWeights</span><span class="p">,</span>
                        <span class="n">maxEdgeLength</span><span class="o">=</span><span class="n">maxEdgeLength</span><span class="p">,</span>
                        <span class="n">counter</span><span class="o">=</span><span class="n">counter</span><span class="p">),</span> 
                <span class="n">dictIterator</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Bypassed&quot;</span><span class="p">,</span> <span class="n">dictIterator</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="s2">&quot;out of&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertexIndices</span><span class="p">),</span>
                  <span class="s2">&quot;vertices (</span><span class="si">{:6.2%}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dictIterator</span><span class="o">.</span><span class="n">count</span><span class="o">/</span>
                                               <span class="nb">len</span><span class="p">(</span><span class="n">vertexIndices</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        
    
    <span class="k">def</span> <span class="nf">_determine_vertex_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">reachBound</span><span class="p">,</span> <span class="n">expansionBound</span><span class="p">,</span> 
                                 <span class="n">degreeBound</span><span class="p">,</span> <span class="n">maxEdgeLength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                 <span class="n">vertexWeights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">vertexWeights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vertexIndex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vertexWeights</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">counter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">percentage</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentage</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
        <span class="n">vertexData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
        <span class="n">successors</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;tmp_successors&quot;</span><span class="p">]</span>
        <span class="n">predecessors</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;tmp_predecessors&quot;</span><span class="p">]</span>
        <span class="n">successorArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span>
        <span class="n">costBound</span> <span class="o">=</span> <span class="n">reachBound</span> <span class="o">/</span> <span class="mi">2</span>
        
        <span class="c1"># check simple absolute bounds</span>
        
        <span class="n">inDegree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span>
        <span class="n">outDegree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">successors</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inDegree</span> <span class="o">+</span> <span class="n">outDegree</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">vertexWeights</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            
        <span class="c1"># 1. Degree bound  </span>
        <span class="k">if</span> <span class="n">inDegree</span> <span class="o">&gt;=</span> <span class="n">degreeBound</span> <span class="ow">or</span> <span class="n">outDegree</span> <span class="o">&gt;=</span> <span class="n">degreeBound</span><span class="p">:</span>
            <span class="c1"># the degree can decrease within one bypassing run, if neighbors</span>
            <span class="c1"># get deleted</span>
            <span class="k">if</span> <span class="n">vertexWeights</span><span class="p">:</span>
                <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># determining expansion (# of new edges (including remaining old edges)</span>
        <span class="c1">#                             / # of old edges)</span>
        <span class="k">if</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;significant&quot;</span><span class="p">]:</span>
            <span class="n">replaceEdges</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">replaceEdges</span> <span class="o">=</span> <span class="p">(</span><span class="n">inDegree</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">])</span>
                            <span class="ow">and</span>
                            <span class="n">outDegree</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]))</span>
        
        <span class="n">lengthArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        <span class="n">inPenalty</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;inPenalty_original&quot;</span><span class="p">]</span>
        <span class="n">outPenalty</span> <span class="o">=</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;outPenalty&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">maxEdgeLength</span> <span class="ow">and</span> <span class="n">successors</span> <span class="ow">and</span> <span class="n">predecessors</span><span class="p">:</span>
            <span class="n">successorEdgeList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">predecessorEdgeList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">predecessors</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">successorList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">predecessorList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">predecessors</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">maxSuc1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lengthArr</span><span class="p">[</span><span class="n">successorEdgeList</span><span class="p">])</span>
            <span class="n">maxSucVal1</span> <span class="o">=</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">successorEdgeList</span><span class="p">[</span><span class="n">maxSuc1</span><span class="p">]]</span>
            <span class="n">maxPred2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lengthArr</span><span class="p">[</span><span class="n">predecessorEdgeList</span><span class="p">])</span>
            <span class="n">maxPredVal2</span> <span class="o">=</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">predecessorEdgeList</span><span class="p">[</span><span class="n">maxPred2</span><span class="p">]]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">predecessorEdgeList</span><span class="p">[</span><span class="n">predecessorList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">successorList</span><span class="p">[</span><span class="n">maxSuc1</span><span class="p">])]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">successorEdgeList</span><span class="p">[</span><span class="n">successorList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">predecessorList</span><span class="p">[</span><span class="n">maxPred2</span><span class="p">])]</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            
            <span class="n">maxLen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">predecessorEdgeList</span><span class="p">:</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="n">maxSucVal1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lengthArr</span><span class="p">[</span><span class="n">predecessorEdgeList</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">successorEdgeList</span><span class="p">:</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxPredVal2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">lengthArr</span><span class="p">[</span><span class="n">successorEdgeList</span><span class="p">]),</span> <span class="n">maxLen</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">maxLen</span> <span class="o">&gt;</span> <span class="n">maxEdgeLength</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vertexWeights</span><span class="p">:</span>
                    <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                
        <span class="k">if</span> <span class="n">expansionBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stopper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="c1"># if we cannot replace edges, we are not allowed to create as </span>
            <span class="c1"># many new edges </span>
            <span class="n">stopper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">outDegree</span><span class="o">+</span><span class="n">inDegree</span><span class="p">)</span> <span class="o">*</span> 
                          <span class="p">(</span><span class="n">expansionBound</span><span class="o">-</span><span class="p">(</span><span class="ow">not</span> <span class="n">replaceEdges</span><span class="p">)),</span> 
                          <span class="mi">2</span><span class="o">*</span><span class="n">degreeBound</span> <span class="o">-</span> <span class="n">inDegree</span> <span class="o">-</span> <span class="n">outDegree</span><span class="p">)</span>
        
        
        <span class="c1"># Could use list comprehension in order to improve speed...</span>
        <span class="n">newEdgeCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">successorItem</span><span class="p">,</span> <span class="n">predecessorItem</span> <span class="ow">in</span> <span class="n">iterproduct</span><span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> 
                                                          <span class="n">predecessors</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">successor</span><span class="p">,</span> <span class="n">successorEdge</span> <span class="o">=</span> <span class="n">successorItem</span>
            <span class="n">predecessor</span><span class="p">,</span> <span class="n">predecessorEdge</span> <span class="o">=</span> <span class="n">predecessorItem</span>
            <span class="k">if</span> <span class="n">successor</span> <span class="o">==</span> <span class="n">predecessor</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="n">newEdgeCount</span> <span class="o">+=</span> <span class="n">successor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">successorArr</span><span class="p">[</span><span class="n">predecessor</span><span class="p">]</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lengthArr</span><span class="p">[</span><span class="n">successorEdge</span><span class="p">]</span> <span class="o">+</span> <span class="n">inPenalty</span><span class="p">,</span>
                       <span class="n">lengthArr</span><span class="p">[</span><span class="n">predecessorEdge</span><span class="p">]</span> <span class="o">+</span> <span class="n">outPenalty</span><span class="p">,</span>
                       <span class="n">lengthArr</span><span class="p">[</span><span class="n">successorEdge</span><span class="p">]</span> <span class="o">+</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">predecessorEdge</span><span class="p">],</span>
                       <span class="n">cost</span><span class="p">)</span>
            
            <span class="c1"># 2. Expansion bound</span>
            <span class="k">if</span> <span class="n">newEdgeCount</span> <span class="o">&gt;</span> <span class="n">stopper</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vertexWeights</span><span class="p">:</span>
                    <span class="c1"># the expansion can change within this bypassing round</span>
                    <span class="c1"># =&gt; we do not delete the vertex</span>
                    <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            
            <span class="c1"># 3. Cost bound</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="o">&gt;</span> <span class="n">costBound</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">vertexWeights</span><span class="p">:</span>
                    <span class="c1"># the vertex cost can only decrease within this round if the</span>
                    <span class="c1"># triangle inequality is not satisfied. Though this is possile,</span>
                    <span class="c1"># it will not happen often and reexamining the vertex again</span>
                    <span class="c1"># would not be worth it =&gt; we delete the vertex</span>
                    <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    
        
        <span class="n">expansion</span> <span class="o">=</span> <span class="n">newEdgeCount</span> <span class="o">/</span> <span class="p">(</span><span class="n">outDegree</span> <span class="o">+</span> <span class="n">inDegree</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="ow">not</span> <span class="n">replaceEdges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertexWeights</span><span class="p">:</span>
            <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">expansion</span> <span class="o">*</span> <span class="n">cost</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expansion</span> <span class="o">*</span> <span class="n">cost</span>
    
    <span class="k">def</span> <span class="nf">_bypass_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">reachBound</span><span class="p">,</span> <span class="n">expansionBound</span><span class="p">,</span> 
                        <span class="n">degreeBound</span><span class="p">,</span> <span class="n">vertexWeights</span><span class="p">,</span> <span class="n">maxEdgeLength</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">counter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># note: if the vertex does not belong to any shortest path that is </span>
        <span class="c1">#       not included in G&#39; anymore, we can completely remove it from</span>
        <span class="c1">#       the graph (i.e. replace edges instead of only adding ne ones)</span>
        
        <span class="k">if</span> <span class="n">counter</span><span class="p">:</span> 
            <span class="n">count</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">count</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">edgeArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span>
        <span class="n">vertexArr</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">array</span>
        <span class="n">successorArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span>
        <span class="n">predecessorArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span>
        <span class="n">tmp_successorArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;tmp_successors&quot;</span><span class="p">]</span>
        <span class="n">tmp_predecessorArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;tmp_predecessors&quot;</span><span class="p">]</span>
        <span class="n">inPenaltyArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;inPenalty_original&quot;</span><span class="p">]</span>
        <span class="n">outPenaltyArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;outPenalty&quot;</span><span class="p">]</span>
        <span class="n">successors</span> <span class="o">=</span> <span class="n">tmp_successorArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
        <span class="n">predecessors</span> <span class="o">=</span> <span class="n">tmp_predecessorArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
        <span class="n">lengthArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        <span class="n">consideredArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">]</span>
        <span class="n">reachBoundArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
        <span class="n">inspectionArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;inspection&quot;</span><span class="p">]</span>
        <span class="n">previousNeighbors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">iterchain</span><span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> 
                                          <span class="n">predecessors</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        
        <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;unbounded&quot;</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;significant&quot;</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">]:</span>
            <span class="n">replaceEdges</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">replaceEdges</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predecessors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">predecessorArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">])</span>
                            <span class="ow">and</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">successors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">successorArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replaceEdges</span><span class="p">:</span>
            <span class="n">inPenalty</span> <span class="o">=</span> <span class="n">inPenaltyArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
            <span class="n">outPenalty</span> <span class="o">=</span> <span class="n">outPenaltyArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
        
        <span class="n">changeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span>
        <span class="k">for</span> <span class="n">successorItem</span><span class="p">,</span> <span class="n">predecessorItem</span> <span class="ow">in</span> <span class="n">iterproduct</span><span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> 
                                                          <span class="n">predecessors</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">successor</span><span class="p">,</span> <span class="n">successorEdge</span> <span class="o">=</span> <span class="n">successorItem</span>
            <span class="n">predecessor</span><span class="p">,</span> <span class="n">predecessorEdge</span> <span class="o">=</span> <span class="n">predecessorItem</span>
            
            <span class="c1"># introduce new edges</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">successor</span> <span class="o">==</span> <span class="n">predecessor</span><span class="p">:</span>
                <span class="n">newLength</span> <span class="o">=</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">successorEdge</span><span class="p">]</span> <span class="o">+</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">predecessorEdge</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">newLength</span> <span class="o">&gt;</span> <span class="n">maxEdgeLength</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vertexIndex</span> <span class="ow">in</span> <span class="n">vertexWeights</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;vertexWeights[vertexIndex]&quot;</span><span class="p">,</span> <span class="n">vertexWeights</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;vertex not in VertexWeights&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Too long edge inserted&quot;</span><span class="p">,</span> <span class="n">vertexArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">][</span><span class="s2">&quot;ID&quot;</span><span class="p">],</span> <span class="n">newLength</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">_determine_vertex_weight</span><span class="p">(</span><span class="n">vertexIndex</span><span class="p">,</span>
                        <span class="n">reachBound</span><span class="o">=</span><span class="n">reachBound</span><span class="p">,</span> 
                        <span class="n">expansionBound</span><span class="o">=</span><span class="n">expansionBound</span><span class="p">,</span> 
                        <span class="n">degreeBound</span><span class="o">=</span><span class="n">degreeBound</span><span class="p">,</span>
                        <span class="n">maxEdgeLength</span><span class="o">=</span><span class="n">maxEdgeLength</span><span class="p">))</span>
                
                <span class="n">successorsOfPredecessor</span> <span class="o">=</span> <span class="n">successorArr</span><span class="p">[</span><span class="n">predecessor</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">successorEdge</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">predecessorEdge</span><span class="p">]:</span>
                        <span class="n">newInspection</span> <span class="o">=</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">successorEdge</span>
                                                      <span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">inspectionArr</span><span class="p">[</span>
                                                          <span class="n">predecessorEdge</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newInspection</span> <span class="o">=</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">successorEdge</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">predecessorEdge</span><span class="p">]:</span> 
                    <span class="n">newInspection</span> <span class="o">=</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">predecessorEdge</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newInspection</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">successor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">successorsOfPredecessor</span><span class="p">:</span>
                    <span class="n">newIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">add_by_keywords</span><span class="p">(</span><span class="n">fromIndex</span><span class="o">=</span><span class="n">predecessor</span><span class="p">,</span> 
                                                  <span class="n">toIndex</span><span class="o">=</span><span class="n">successor</span><span class="p">,</span>
                                                  <span class="n">length</span><span class="o">=</span><span class="n">newLength</span><span class="p">,</span>
                                                  <span class="n">considered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">originalEdge1</span><span class="o">=</span><span class="n">predecessorEdge</span><span class="p">,</span>
                                                  <span class="n">originalEdge2</span><span class="o">=</span><span class="n">successorEdge</span><span class="p">,</span>
                                                  <span class="n">inspection</span><span class="o">=</span><span class="n">newInspection</span><span class="p">)</span>
                    <span class="n">successorArr</span><span class="p">[</span><span class="n">predecessor</span><span class="p">][</span><span class="n">successor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newIndex</span>
                    <span class="n">predecessorArr</span><span class="p">[</span><span class="n">successor</span><span class="p">][</span><span class="n">predecessor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newIndex</span>
                    <span class="n">tmp_successorArr</span><span class="p">[</span><span class="n">predecessor</span><span class="p">][</span><span class="n">successor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newIndex</span>
                    <span class="n">tmp_predecessorArr</span><span class="p">[</span><span class="n">successor</span><span class="p">][</span><span class="n">predecessor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newIndex</span>
                <span class="k">elif</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">successorsOfPredecessor</span><span class="p">[</span><span class="n">successor</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">newLength</span><span class="p">:</span>
                    <span class="n">newIndex</span> <span class="o">=</span> <span class="n">successorsOfPredecessor</span><span class="p">[</span><span class="n">successor</span><span class="p">]</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">setitem_by_keywords</span><span class="p">(</span><span class="n">newIndex</span><span class="p">,</span> <span class="n">fromIndex</span><span class="o">=</span><span class="n">predecessor</span><span class="p">,</span> 
                                           <span class="n">toIndex</span><span class="o">=</span><span class="n">successor</span><span class="p">,</span>
                                           <span class="n">length</span><span class="o">=</span><span class="n">newLength</span><span class="p">,</span> <span class="n">considered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">originalEdge1</span><span class="o">=</span><span class="n">predecessorEdge</span><span class="p">,</span>
                                           <span class="n">originalEdge2</span><span class="o">=</span><span class="n">successorEdge</span><span class="p">,</span>
                                           <span class="n">inspection</span><span class="o">=</span><span class="n">newInspection</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">successor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tmp_successorArr</span><span class="p">[</span><span class="n">predecessor</span><span class="p">]:</span>
                        <span class="n">tmp_successorArr</span><span class="p">[</span><span class="n">predecessor</span><span class="p">][</span><span class="n">successor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newIndex</span>
                        <span class="n">tmp_predecessorArr</span><span class="p">[</span><span class="n">successor</span><span class="p">][</span><span class="n">predecessor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newIndex</span>
                        
        
            <span class="k">if</span> <span class="ow">not</span> <span class="n">changeIndex</span> <span class="o">==</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span><span class="p">:</span>
                <span class="n">edgeArr</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">array</span>
                <span class="n">inspectionArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;inspection&quot;</span><span class="p">]</span>
                <span class="n">lengthArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
                <span class="n">consideredArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;considered&quot;</span><span class="p">]</span>
                <span class="n">reachBoundArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
                <span class="n">changeIndex</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">changeIndex</span>
            
        <span class="c1"># delete old edges     </span>
        <span class="k">for</span> <span class="n">items</span><span class="p">,</span> <span class="n">neighborArr</span> <span class="ow">in</span> <span class="p">((</span><span class="n">successors</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">tmp_predecessorArr</span><span class="p">),</span>
                                   <span class="p">(</span><span class="n">predecessors</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">tmp_successorArr</span><span class="p">)):</span>   
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="c1">#neighborArr[neighbor].pop(vertexIndex, None)</span>
                <span class="k">del</span> <span class="n">neighborArr</span><span class="p">[</span><span class="n">neighbor</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">]</span>
                <span class="n">consideredArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                
        <span class="k">if</span> <span class="n">replaceEdges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">neighborArr</span> <span class="ow">in</span> <span class="p">((</span><span class="n">successors</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">predecessorArr</span><span class="p">),</span>
                                           <span class="p">(</span><span class="n">predecessors</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">successorArr</span><span class="p">)):</span>   
                <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                    <span class="c1">#neighborArr[neighbor].pop(vertexIndex, None)</span>
                    <span class="k">del</span> <span class="n">neighborArr</span><span class="p">[</span><span class="n">neighbor</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">]</span>
            <span class="n">successorArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">predecessorArr</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            
            <span class="c1"># this step is is not necessary, but good style </span>
            <span class="c1"># (setting the reach of deleted edges to 0)</span>
            <span class="k">for</span> <span class="n">neighborEdges</span> <span class="ow">in</span> <span class="p">(</span><span class="n">successors</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">predecessors</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">reachBoundArr</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">neighborEdges</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighborItems</span><span class="p">,</span> <span class="n">penalty</span><span class="p">,</span> <span class="n">penaltyArr</span> <span class="ow">in</span> <span class="p">((</span><span class="n">successors</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> 
                                                        <span class="n">inPenalty</span><span class="p">,</span> 
                                                        <span class="n">inPenaltyArr</span><span class="p">),</span>
                                                       <span class="p">(</span><span class="n">predecessors</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> 
                                                        <span class="n">outPenalty</span><span class="p">,</span>
                                                        <span class="n">outPenaltyArr</span><span class="p">)):</span>   
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">neighborItems</span><span class="p">:</span>
                    <span class="n">vertex</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">item</span>
                    <span class="n">deletedPathLength</span> <span class="o">=</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+</span> <span class="n">penalty</span>
                    
                    <span class="c1"># set reach of deleted edge</span>
                    <span class="n">reachBoundArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">deletedPathLength</span>
                    
                    <span class="c1"># update inpenalty of the neighbor</span>
                    <span class="k">if</span> <span class="n">deletedPathLength</span> <span class="o">&gt;</span> <span class="n">penaltyArr</span><span class="p">[</span><span class="n">vertex</span><span class="p">]:</span> 
                        <span class="n">penaltyArr</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">deletedPathLength</span> 
                    
        
        <span class="n">successors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">predecessors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        
        <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_determine_vertex_weight</span><span class="p">,</span>
                        <span class="n">reachBound</span><span class="o">=</span><span class="n">reachBound</span><span class="p">,</span> 
                        <span class="n">expansionBound</span><span class="o">=</span><span class="n">expansionBound</span><span class="p">,</span> 
                        <span class="n">degreeBound</span><span class="o">=</span><span class="n">degreeBound</span><span class="p">,</span>
                        <span class="n">maxEdgeLength</span><span class="o">=</span><span class="n">maxEdgeLength</span><span class="p">,</span> 
                        <span class="n">vertexWeights</span><span class="o">=</span><span class="n">vertexWeights</span><span class="p">),</span> 
                <span class="n">previousNeighbors</span><span class="p">))</span>
                   
    <span class="k">def</span> <span class="nf">_convert_edge_reaches_to_vertex_reaches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="n">edgeReachArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]):</span>
                <span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            
            <span class="n">predecessorEdgeReaches</span> <span class="o">=</span> <span class="n">edgeReachArr</span><span class="p">[</span>
                                             <span class="nb">list</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                                  <span class="p">]</span>
            <span class="n">successorEdgeReaches</span> <span class="o">=</span> <span class="n">edgeReachArr</span><span class="p">[</span>
                                            <span class="nb">list</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                                <span class="p">]</span>
            
            <span class="n">predecessorList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">successorList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            
            <span class="n">predArgMax1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">predecessorEdgeReaches</span><span class="p">)</span>
            <span class="n">predMax1</span> <span class="o">=</span> <span class="n">predecessorEdgeReaches</span><span class="p">[</span><span class="n">predArgMax1</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">predArgMax1Succ</span> <span class="o">=</span> \
                            <span class="n">successorList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">predecessorList</span><span class="p">[</span><span class="n">predArgMax1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># if maximal predecessor is not successor</span>
                <span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">predMax1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">successorEdgeReaches</span><span class="p">))</span>
                <span class="k">continue</span>
            
            <span class="n">succArgMax2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">successorEdgeReaches</span><span class="p">)</span>
            <span class="n">succMax2</span> <span class="o">=</span> <span class="n">successorEdgeReaches</span><span class="p">[</span><span class="n">succArgMax2</span><span class="p">]</span>
            
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">succArgMax1Pred</span> <span class="o">=</span> \
                            <span class="n">predecessorList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">successorList</span><span class="p">[</span><span class="n">succArgMax2</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># if maximal successor is not predecessor </span>
                <span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">succMax2</span><span class="p">,</span> 
                                        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">predecessorEdgeReaches</span><span class="p">))</span>
                <span class="k">continue</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">succMax1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">reach</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reach</span> <span class="ow">in</span> 
                               <span class="nb">enumerate</span><span class="p">(</span><span class="n">successorEdgeReaches</span><span class="p">)</span> 
                               <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">==</span> <span class="n">predArgMax1Succ</span><span class="p">)</span> 
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">succMax1</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">predMax2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">reach</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reach</span> <span class="ow">in</span> 
                               <span class="nb">enumerate</span><span class="p">(</span><span class="n">predecessorEdgeReaches</span><span class="p">)</span> 
                               <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">==</span> <span class="n">succArgMax1Pred</span><span class="p">)</span> 
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">predMax2</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="n">vertex</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">predMax1</span><span class="p">,</span> <span class="n">succMax1</span><span class="p">),</span> 
                                       <span class="nb">min</span><span class="p">(</span><span class="n">succMax2</span><span class="p">,</span> <span class="n">predMax2</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">_sort_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Sorting the neighbor dictionaries with respect to reach&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;bounds&quot;</span><span class="p">)</span>
        <span class="n">vertexArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">reachArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">ParallelCounter</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">getOrderedDicts</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
            <span class="n">percentage</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">percentage</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentage</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">reachArr</span><span class="p">[</span><span class="n">keys</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">FixedOrderedIntDict</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">order</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">],</span>
                                       <span class="n">neighbors</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="s2">&quot;predecessors&quot;</span><span class="p">,</span> <span class="s2">&quot;successors&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;posix&#39;</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">sharedmem</span><span class="o">.</span><span class="n">MapReduce</span><span class="p">(</span><span class="n">np</span><span class="o">=</span><span class="n">CPU_COUNT</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                    <span class="n">vertexArr</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">getOrderedDicts</span><span class="p">,</span> <span class="n">vertexArr</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vertexArr</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">getOrderedDicts</span><span class="p">,</span> <span class="n">vertexArr</span><span class="p">[</span><span class="n">name</span><span class="p">]))</span>
                
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            with Pool(CPU_COUNT) as pool:</span>
<span class="sd">                vertexArr[name] = pool.map(getOrderedDicts, vertexArr[name])</span>
<span class="sd">            &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="FlowPointGraph.find_shortest_path"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlowPointGraph.find_shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">find_shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromIndex</span><span class="p">,</span> <span class="n">toIndex</span><span class="p">,</span> <span class="n">getPath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                           <span class="n">initSize</span><span class="o">=</span><span class="mi">2000</span><span class="p">):</span>
        <span class="n">vertexArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span>
        <span class="n">reachArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span>
        <span class="n">successorArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span>
        <span class="n">predecessorArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span>
        <span class="n">edgeArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span>
        <span class="n">lengthArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        
        <span class="n">forwardData</span> <span class="o">=</span> <span class="n">FlexibleArrayDict</span><span class="p">(</span><span class="n">initSize</span><span class="p">,</span> 
                                        <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> 
                                                        <span class="s2">&quot;edge&quot;</span><span class="p">],</span>
                                               <span class="s2">&quot;formats&quot;</span><span class="p">:[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]})</span>
        <span class="n">forwardData</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">forwardDataDict</span> <span class="o">=</span> <span class="n">forwardData</span><span class="o">.</span><span class="n">indexDict</span>
        
        <span class="n">backwardData</span> <span class="o">=</span> <span class="n">FlexibleArrayDict</span><span class="p">(</span><span class="n">initSize</span><span class="p">,</span> 
                                         <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> 
                                                         <span class="s2">&quot;edge&quot;</span><span class="p">],</span>
                                                <span class="s2">&quot;formats&quot;</span><span class="p">:[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]})</span>
        <span class="n">backwardData</span><span class="p">[</span><span class="n">toIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">backwardDataDict</span> <span class="o">=</span> <span class="n">backwardData</span><span class="o">.</span><span class="n">indexDict</span>
        
        <span class="n">forwardQueue</span> <span class="o">=</span> <span class="n">intquickheapdict</span><span class="p">(((</span><span class="n">fromIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span> <span class="n">initSize</span><span class="p">)</span>
        <span class="n">backwardQueue</span> <span class="o">=</span> <span class="n">intquickheapdict</span><span class="p">(((</span><span class="n">toIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span> <span class="n">initSize</span><span class="p">)</span>
        
        <span class="n">forwardVertex</span><span class="p">,</span> <span class="n">forwardCost</span> <span class="o">=</span> <span class="n">fromIndex</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">backwardVertex</span><span class="p">,</span> <span class="n">backwardCost</span> <span class="o">=</span> <span class="n">toIndex</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">bestLength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="k">while</span> <span class="n">bestLength</span> <span class="o">&gt;</span> <span class="n">forwardCost</span> <span class="o">+</span> <span class="n">backwardCost</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">forwardCost</span> <span class="o">&lt;=</span> <span class="n">backwardCost</span><span class="p">:</span>
                <span class="n">thisQueue</span> <span class="o">=</span> <span class="n">forwardQueue</span>
                <span class="n">oppositeQueue</span> <span class="o">=</span> <span class="n">backwardQueue</span>
                <span class="n">thisVertex</span> <span class="o">=</span> <span class="n">forwardVertex</span>
                <span class="n">thisCost</span> <span class="o">=</span> <span class="n">forwardCost</span>
                <span class="n">oppositeCost</span> <span class="o">=</span> <span class="n">backwardCost</span>
                <span class="n">neighborArr</span> <span class="o">=</span> <span class="n">successorArr</span>
                <span class="n">thisDataDict</span> <span class="o">=</span> <span class="n">forwardDataDict</span>
                <span class="n">thisData</span> <span class="o">=</span> <span class="n">forwardData</span>
                <span class="n">oppositeDataDict</span> <span class="o">=</span> <span class="n">backwardDataDict</span>
                <span class="n">oppositeData</span> <span class="o">=</span> <span class="n">backwardData</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thisQueue</span> <span class="o">=</span> <span class="n">backwardQueue</span>
                <span class="n">oppositeQueue</span> <span class="o">=</span> <span class="n">forwardQueue</span>
                <span class="n">thisVertex</span> <span class="o">=</span> <span class="n">backwardVertex</span>
                <span class="n">thisCost</span> <span class="o">=</span> <span class="n">backwardCost</span>
                <span class="n">oppositeCost</span> <span class="o">=</span> <span class="n">forwardCost</span>
                <span class="n">neighborArr</span> <span class="o">=</span> <span class="n">predecessorArr</span>
                <span class="n">thisDataDict</span> <span class="o">=</span> <span class="n">backwardDataDict</span>
                <span class="n">thisData</span> <span class="o">=</span> <span class="n">backwardData</span>
                <span class="n">oppositeDataDict</span> <span class="o">=</span> <span class="n">forwardDataDict</span>
                <span class="n">oppositeData</span> <span class="o">=</span> <span class="n">forwardData</span>
                
            
            <span class="c1"># delete item from queue</span>
            <span class="n">thisQueue</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            
            <span class="c1"># prune, if necessary (This step is necessary, since</span>
            <span class="c1"># early pruning is weakened in order to allow for the fancy</span>
            <span class="c1"># termination criterion</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">reachArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">thisCost</span><span class="p">:</span>
                    
                <span class="c1"># check whether the vertex has been labeled from the opposite </span>
                <span class="c1"># side</span>
                <span class="n">reverseCost</span> <span class="o">=</span> <span class="n">oppositeQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">thisVertex</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">reverseCost</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>                             <span class="c1"># if yes</span>
                    <span class="n">totalLength</span> <span class="o">=</span> <span class="n">thisCost</span> <span class="o">+</span> <span class="n">reverseCost</span>
                    <span class="c1"># update best path if necessary</span>
                    <span class="k">if</span> <span class="n">totalLength</span> <span class="o">&lt;</span> <span class="n">bestLength</span><span class="p">:</span>
                        <span class="n">bestLength</span> <span class="o">=</span> <span class="n">totalLength</span>
                        <span class="n">bestPathMiddleEdge</span> <span class="o">=</span> <span class="n">oppositeData</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;edge&quot;</span><span class="p">]</span>
                
                <span class="c1"># set the vertex cost           </span>
                <span class="n">thisData</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;cost&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisCost</span>
                
                <span class="c1"># process successors</span>
                <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">neighborArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    
                    <span class="c1"># early pruning</span>
                    <span class="n">reach</span> <span class="o">=</span> <span class="n">reachArr</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
                    <span class="n">newCost</span> <span class="o">=</span> <span class="n">thisCost</span> <span class="o">+</span> <span class="n">length</span>
                    <span class="k">if</span> <span class="n">reach</span> <span class="o">&lt;</span> <span class="n">oppositeCost</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">reach</span> <span class="o">&lt;</span> <span class="n">thisCost</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">reach</span> <span class="o">&lt;</span> <span class="n">newCost</span><span class="p">:</span>
                            <span class="k">continue</span>
                    
                    <span class="c1"># if not pruned</span>
                    <span class="n">neighborCost</span> <span class="o">=</span> <span class="n">thisQueue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">neighborCost</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># if neighbor is in the queue</span>
                        <span class="k">if</span> <span class="n">neighborCost</span> <span class="o">&gt;</span> <span class="n">newCost</span><span class="p">:</span>
                            <span class="n">neighborData</span> <span class="o">=</span> <span class="n">thisData</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
                            <span class="n">neighborData</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisVertex</span>
                            <span class="n">neighborData</span><span class="p">[</span><span class="s2">&quot;edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>
                            <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">update</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#check whether neighbor already scanned</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">thisDataDict</span><span class="p">:</span>
                            <span class="n">thisData</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">thisVertex</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
                            <span class="n">update</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">update</span> <span class="o">=</span> <span class="kc">False</span>
                        
                    <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
                        <span class="n">thisQueue</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisCost</span> <span class="o">+</span> <span class="n">length</span>
                        
                        <span class="c1"># check whether neighbor has been scanned from the</span>
                        <span class="c1"># opposite direction and update the best path </span>
                        <span class="c1"># if necessary</span>
                        <span class="n">oppositeIntIndex</span> <span class="o">=</span> <span class="n">oppositeDataDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">oppositeIntIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">reverseCost</span> <span class="o">=</span> <span class="n">oppositeData</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span>
                                                             <span class="p">][</span><span class="n">oppositeIntIndex</span><span class="p">]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">reverseCost</span><span class="p">):</span>
                                <span class="n">totalLength</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisCost</span> <span class="o">+</span> <span class="n">length</span> 
                                               <span class="o">+</span> <span class="n">reverseCost</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">totalLength</span> <span class="o">&lt;</span> <span class="n">bestLength</span><span class="p">:</span>
                                    <span class="n">bestLength</span> <span class="o">=</span> <span class="n">totalLength</span>
                                    <span class="n">bestPathMiddleEdge</span> <span class="o">=</span> <span class="n">edge</span>
            
            <span class="k">if</span> <span class="n">bestLength</span> <span class="o">&gt;</span> <span class="n">forwardCost</span> <span class="o">+</span> <span class="n">backwardCost</span><span class="p">:</span>        
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">forwardCost</span> <span class="o">&lt;=</span> <span class="n">backwardCost</span><span class="p">:</span>
                        <span class="n">forwardVertex</span><span class="p">,</span> <span class="n">forwardCost</span> <span class="o">=</span> <span class="n">thisQueue</span><span class="o">.</span><span class="n">peekitem</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">backwardVertex</span><span class="p">,</span> <span class="n">backwardCost</span> <span class="o">=</span> <span class="n">thisQueue</span><span class="o">.</span><span class="n">peekitem</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Vertices </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> are disconnected.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">fromIndex</span><span class="p">][</span><span class="s2">&quot;ID&quot;</span><span class="p">],</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">toIndex</span><span class="p">][</span><span class="s2">&quot;ID&quot;</span><span class="p">]))</span>
                    <span class="k">break</span>
        
        <span class="k">if</span> <span class="n">getPath</span><span class="p">:</span>
            <span class="n">fromIndexArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;fromIndex&quot;</span><span class="p">]</span>
            <span class="n">toIndexArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">]</span>
            <span class="n">originalEdgeArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[[</span><span class="s2">&quot;originalEdge2&quot;</span><span class="p">,</span> <span class="s2">&quot;originalEdge1&quot;</span><span class="p">]]</span>
            <span class="n">isShortcutArr</span> <span class="o">=</span> <span class="n">edgeArr</span><span class="p">[</span><span class="s2">&quot;originalEdge1&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            
            <span class="k">def</span> <span class="nf">expandEdge</span><span class="p">(</span><span class="n">edgeIndex</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">edgeIndex</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">isShortcutArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                        <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">originalEdgeArr</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            
            <span class="n">pathEdgeIndices</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">expandEdge</span><span class="p">(</span><span class="n">bestPathMiddleEdge</span><span class="p">))</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">fromIndexArr</span><span class="p">[</span><span class="n">pathEdgeIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">fromIndex</span><span class="p">:</span>
                <span class="n">pathEdgeIndices</span><span class="o">.</span><span class="n">extendleft</span><span class="p">(</span><span class="n">expandEdge</span><span class="p">(</span><span class="n">forwardData</span><span class="p">[</span><span class="n">fromIndexArr</span><span class="p">[</span>
                                           <span class="n">pathEdgeIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="s2">&quot;edge&quot;</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">toIndexArr</span><span class="p">[</span><span class="n">pathEdgeIndices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">toIndex</span><span class="p">:</span>
                <span class="n">pathEdgeIndices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expandEdge</span><span class="p">(</span><span class="n">backwardData</span><span class="p">[</span><span class="n">toIndexArr</span><span class="p">[</span>
                                              <span class="n">pathEdgeIndices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]][</span><span class="s2">&quot;edge&quot;</span><span class="p">]))</span>
            
            <span class="k">return</span> <span class="n">bestLength</span><span class="p">,</span> <span class="n">edgeArr</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">pathEdgeIndices</span><span class="p">)]</span>
        
        <span class="k">return</span> <span class="n">bestLength</span></div>
    
    
    
<div class="viewcode-block" id="FlowPointGraph.find_shortest_distance_array"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlowPointGraph.find_shortest_distance_array">[docs]</a>    <span class="k">def</span> <span class="nf">find_shortest_distance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromIndices</span><span class="p">,</span> <span class="n">toIndices</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Computing shortest distance array&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        <span class="n">sinkNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">toIndices</span><span class="p">)</span>
        <span class="n">sourceNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromIndices</span><span class="p">)</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">sourceNumber</span><span class="p">,</span> <span class="n">sinkNumber</span><span class="p">))</span>
        <span class="n">sourceSinkCombinations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">iterproduct</span><span class="p">(</span><span class="n">fromIndices</span><span class="p">,</span> 
                                                           <span class="n">toIndices</span><span class="p">)))</span>
        
        <span class="n">combinationNumber</span> <span class="o">=</span> <span class="n">sourceSinkCombinations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">chunk_number</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="n">min_chunk_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">cpu_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">CPU_COUNT</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sourceSinkCombinations</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">chunksize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_chunk_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sourceSinkCombinations</span><span class="p">)</span><span class="o">//</span>
                        <span class="p">(</span><span class="n">cpu_count</span><span class="o">*</span><span class="n">chunk_number</span><span class="p">))</span>
        
        <span class="n">const_args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        
        <span class="n">printCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">combinationNumber</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        
        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="n">find_shortest_distance</span><span class="p">,</span>
                        <span class="n">sourceSinkCombinations</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">sourceSinkCombinations</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span>
                        <span class="p">)</span>
                                                                 
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapObj</span><span class="p">):</span>
                    <span class="n">percentage</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">percentage</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentage</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">dists</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="n">sinkNumber</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="n">sinkNumber</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">dists</span></div>
        
<div class="viewcode-block" id="FlowPointGraph.find_alternative_paths"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlowPointGraph.find_alternative_paths">[docs]</a>    <span class="k">def</span> <span class="nf">find_alternative_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The function `find_alternative_paths` has been renamed&quot;</span>
                      <span class="s2">&quot;to `find_locally_optimal_paths.`&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_locally_optimal_paths</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FlowPointGraph.find_locally_optimal_paths"><a class="viewcode-back" href="../../lopaths/lopaths.graph.html#lopaths.graph.FlowPointGraph.find_locally_optimal_paths">[docs]</a>    <span class="k">def</span> <span class="nf">find_locally_optimal_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromIndices</span><span class="p">,</span> <span class="n">toIndices</span><span class="p">,</span> 
                               <span class="n">shortestDistances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">stretchConstant</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>         <span class="c1"># beta</span>
                               <span class="n">localOptimalityConstant</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># alpha</span>
                               <span class="n">acceptionFactor</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                               <span class="n">rejectionFactor</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
                               <span class="n">testing</span><span class="o">=</span><span class="kc">False</span>
                               <span class="p">):</span>           
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Finding alternative paths (parallelly)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Stretch Constant:&quot;</span><span class="p">,</span> <span class="n">stretchConstant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;local Optimality Constant:&quot;</span><span class="p">,</span> <span class="n">localOptimalityConstant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;acception factor:&quot;</span><span class="p">,</span> <span class="n">acceptionFactor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;rejection factor:&quot;</span><span class="p">,</span> <span class="n">rejectionFactor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;|O|, |D| = &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromIndices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">toIndices</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">testing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Testing:&quot;</span><span class="p">,</span> <span class="n">testing</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">testing</span><span class="p">,</span> <span class="s2">&quot;__contains__&quot;</span><span class="p">):</span>
            <span class="n">testing_args</span> <span class="o">=</span> <span class="n">testing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">testing_args</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="n">testResults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:{},</span> <span class="s2">&quot;result&quot;</span><span class="p">:{}}</span>
        
        
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">startTimeTot</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="c1"># compute shortest distances @@@</span>
        <span class="k">if</span> <span class="n">shortestDistances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_shortest_distance_array</span><span class="p">(</span><span class="n">fromIndices</span><span class="p">,</span> <span class="n">toIndices</span><span class="p">)</span>
            <span class="c1"># treat disconnected sources and sinks well</span>
            <span class="n">sourcesConsidered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">sinksConsidered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">sourcesConsidered</span><span class="p">][:,</span><span class="n">sinksConsidered</span><span class="p">]</span>
            <span class="n">fromIndices</span> <span class="o">=</span> <span class="n">fromIndices</span><span class="p">[</span><span class="n">sourcesConsidered</span><span class="p">]</span>
            <span class="n">toIndices</span> <span class="o">=</span> <span class="n">toIndices</span><span class="p">[</span><span class="n">sinksConsidered</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dists</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Some sources and sinks are disconnected though &quot;</span> <span class="o">+</span>
                              <span class="s2">&quot;no source is separated from all sinks and &quot;</span> <span class="o">+</span>
                              <span class="s2">&quot;vice versa. That is, the graph has separate &quot;</span> <span class="o">+</span>
                              <span class="s2">&quot;subgraphs.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">shortestDistances</span>
        
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;shortest path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Searching shortest paths took </span><span class="si">{}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">endTime</span>
        
        <span class="n">max_source_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">max_sink_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">min_source_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">min_sink_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="n">sourceNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fromIndices</span><span class="p">)</span>
        <span class="n">sinkNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">toIndices</span><span class="p">)</span>

        <span class="n">startIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">fromIndices</span><span class="p">,</span> <span class="n">toIndices</span><span class="p">))</span>
        
        <span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
        <span class="n">closestSourceQueue</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        
        <span class="n">cpu_count</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">CPU_COUNT</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">sinkNumber</span><span class="o">//</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">const_args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> 
                      <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;inspection&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
                      <span class="n">stretchConstant</span><span class="p">,</span> <span class="n">localOptimalityConstant</span><span class="p">,</span> 
                      <span class="n">closestSourceQueue</span><span class="p">]</span>
        
        <span class="n">taskLength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">startIndices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Labelling vertices.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        
        <span class="n">printCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">taskLength</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">)</span>
        
        <span class="n">labelData</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">closestSourceDists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">edgesVisitedSources</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">edgesVisitedSinks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        
        <span class="c1"># task must be split to have the correct lower distence bounds</span>
        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_grow_bounded_tree</span><span class="p">,</span>
                              <span class="n">fromIndices</span><span class="p">,</span> <span class="n">Repeater</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="n">min_source_dists</span><span class="p">,</span>
                              <span class="n">max_source_dists</span><span class="p">,</span> 
                              <span class="n">Repeater</span><span class="p">(</span><span class="s2">&quot;tree_bound&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">),</span>
                              <span class="n">Repeater</span><span class="p">(</span><span class="s2">&quot;pruning_bound&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">),</span>
                              <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">decreaseThread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
                        <span class="n">target</span><span class="o">=</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_decrease_closest_source_distance</span><span class="p">,</span> 
                        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">closestSourceQueue</span><span class="p">,</span> <span class="n">closestSourceDists</span><span class="p">)</span>
                        <span class="p">)</span>
            <span class="n">decreaseThread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapObj</span><span class="p">):</span>
                <span class="n">percentageDone</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">percentageDone</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentageDone</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">tree</span><span class="p">,</span> <span class="n">edgesVisited</span> <span class="o">=</span> <span class="n">item</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">edgesVisited</span><span class="p">:</span>
                    <span class="n">edgesVisitedSources</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">labelData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            
            <span class="n">closestSourceQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">decreaseThread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Processed sources. Now processing the sinks.&quot;</span><span class="p">)</span>
        <span class="n">const_args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">closestSourceDists</span>
        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_grow_bounded_tree</span><span class="p">,</span>
                              <span class="n">toIndices</span><span class="p">,</span> 
                              <span class="n">Repeater</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span> <span class="n">min_sink_dists</span><span class="p">,</span> <span class="n">max_sink_dists</span><span class="p">,</span> 
                              <span class="n">Repeater</span><span class="p">(</span><span class="s2">&quot;tree_bound&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">),</span>
                              <span class="n">Repeater</span><span class="p">(</span><span class="s2">&quot;pruning_bound&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">),</span>
                              <span class="n">Repeater</span><span class="p">(</span><span class="s2">&quot;pruning_bound_extended&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">),</span>
                              <span class="n">chunksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapObj</span><span class="p">):</span>
                <span class="n">percentageDone</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">percentageDone</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentageDone</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">tree</span><span class="p">,</span> <span class="n">edgesVisited</span> <span class="o">=</span> <span class="n">item</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">edgesVisited</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">edgesVisitedSources</span><span class="p">:</span>
                        <span class="n">edgesVisitedSinks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">labelData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Vertex labelling done.&quot;</span><span class="p">)</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;labelling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Labelling took </span><span class="si">{}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">endTime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        
        
        
        <span class="n">consideredEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">edgesVisitedSinks</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        
        
        <span class="k">if</span> <span class="s2">&quot;reject_identical&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span> <span class="ow">or</span> <span class="s2">&quot;find_plateaus&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">:</span>
            <span class="n">plateauPeakEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">consideredEdges</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="n">edgesVisitedSources</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plateauPeakEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_plateau_peaks</span><span class="p">(</span><span class="n">consideredEdges</span><span class="p">,</span> 
                                                        <span class="n">edgesVisitedSources</span><span class="p">,</span>
                                                        <span class="n">edgesVisitedSinks</span><span class="p">)</span>
        
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;number plateau peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plateauPeakEdges</span><span class="p">)</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;number labelled edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">consideredEdges</span><span class="p">)</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;plateau peaks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Identifying plateau peaks took </span><span class="si">{}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">endTime</span>
        
        <span class="n">lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">plateauPeakEdges</span><span class="p">]</span>
        <span class="c1">#print(&quot;Mean length&quot;, np.mean(lengths))</span>
        <span class="c1">#print(&quot;50th, 60th, 70th, 80th, 90th, 95th  percentile&quot;, np.percentile(lengths, [50, 60, 70, 80, 90, 95]))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Noting the distances from the significant edges&quot;</span><span class="p">,</span>
                  <span class="s2">&quot;to all sources and sinks&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        
        
        <span class="n">findPairProduct</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgesVisitedSources</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">edgesVisitedSinks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">findPairProduct</span><span class="p">,</span> 
                                     <span class="n">plateauPeakEdges</span><span class="p">)))</span>
        
        
        <span class="n">plateauPeakEdges</span> <span class="o">=</span> <span class="n">plateauPeakEdges</span><span class="p">[</span><span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        
        
        <span class="n">taskLength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plateauPeakEdges</span><span class="p">)</span>
        <span class="n">const_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">labelData</span><span class="p">]</span>
        
        <span class="n">sourceDistances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">taskLength</span><span class="p">,</span> <span class="n">sourceNumber</span><span class="p">))</span>
        <span class="n">sinkDistances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">taskLength</span><span class="p">,</span> <span class="n">sinkNumber</span><span class="p">))</span>
        <span class="n">printCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">taskLength</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">)</span>
        
        <span class="c1"># we only need to consider the toIndex of the edges,</span>
        <span class="c1"># because the outer vertex might have been pruned in the </span>
        <span class="c1"># backwards labelling process and there the outer vertex is the</span>
        <span class="c1"># fromVertex</span>
        
        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_get_edge_source_sink_distances</span><span class="p">,</span>
                              <span class="p">[</span><span class="n">edgesVisitedSources</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">plateauPeakEdges</span><span class="p">],</span>
                              <span class="p">[</span><span class="n">edgesVisitedSinks</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">plateauPeakEdges</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">][</span><span class="n">plateauPeakEdges</span><span class="p">],</span>
                              <span class="n">repeat</span><span class="p">(</span><span class="n">sourceNumber</span><span class="p">),</span> <span class="n">repeat</span><span class="p">(</span><span class="n">sinkNumber</span><span class="p">),</span>
                              <span class="n">tasklength</span><span class="o">=</span><span class="n">taskLength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">distanceTuple</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapObj</span><span class="p">):</span>
                <span class="n">percentageDone</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">percentageDone</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentageDone</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">sourceDistances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distanceTuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sinkDistances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distanceTuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;source sink distance preparation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Noting distances to sources and sinks took </span><span class="si">{}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">endTime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Determining unique candidates per plateau.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        
        <span class="n">taskLength</span> <span class="o">=</span> <span class="n">sourceNumber</span><span class="o">*</span><span class="n">sinkNumber</span>
        <span class="n">printCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">taskLength</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">)</span>
        
        <span class="n">const_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">sourceDistances</span><span class="p">,</span> <span class="n">sinkDistances</span><span class="p">,</span> 
                      <span class="n">stretchConstant</span><span class="p">,</span> 
                      <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">][</span><span class="n">plateauPeakEdges</span><span class="p">])</span>
        
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sink&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)]</span>
        <span class="n">pairData</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">FlexibleArray</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
        
        <span class="n">pairVertexCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_find_vertexCandidates</span><span class="p">,</span>
                <span class="n">iterproduct</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sourceNumber</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">sinkNumber</span><span class="p">)),</span>
                <span class="n">repeat</span><span class="p">(</span><span class="s2">&quot;reject_identical&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">testing_args</span><span class="p">),</span> <span class="n">tasklength</span><span class="o">=</span><span class="n">taskLength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pair</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">iterproduct</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sourceNumber</span><span class="p">),</span> 
                                             <span class="nb">range</span><span class="p">(</span><span class="n">sinkNumber</span><span class="p">)),</span> <span class="n">mapObj</span><span class="p">):</span>
                <span class="n">pairViaVertices</span><span class="p">,</span> <span class="n">lengths</span> <span class="o">=</span> <span class="n">res</span>
                <span class="n">percentageDone</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">percentageDone</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentageDone</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pairViaVertices</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
                    <span class="n">pairData</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">add_tuple</span><span class="p">((</span><span class="o">*</span><span class="n">pair</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span> 
                <span class="n">pairVertexCount</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairViaVertices</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> via candidates are left. (</span><span class="si">{}</span><span class="s2"> vertices per pair)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">pairData</span><span class="p">),</span> <span class="n">pairVertexCount</span><span class="o">/</span><span class="n">sourceNumber</span><span class="o">/</span><span class="n">sinkNumber</span><span class="p">))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;length and uniqueness&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;number unique candidates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairData</span><span class="p">)</span>
        <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;number unique candidates pair&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairVertexCount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Determining unique candidates per plateau took </span><span class="si">{}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">endTime</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Checking the admissibility of the candidate vertices.&quot;</span><span class="p">)</span>
        <span class="n">taskLength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairData</span><span class="p">)</span>
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        
        
        <span class="n">printCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">taskLength</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">)</span>
        <span class="n">chunksize</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">if</span> <span class="n">taskLength</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">cpu_count</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cpu_count</span> <span class="o">=</span> <span class="mi">1</span>
        
        <span class="c1"># We cannot use only the vertices, because if a vertex appears once </span>
        <span class="c1"># with sources 1, 2, 3 and sinks A, B  and once with 2, B, C, then</span>
        <span class="c1"># merging sinks and sources would leave us with 1, 2, 3 times A, B, C.</span>
        <span class="c1"># This could become a very disadvantageous increase in combinations.</span>
        <span class="c1"># Furthermore, we only want to consider sources and sinks that reach</span>
        <span class="c1"># the vertex from different directions. </span>
        <span class="c1"># Therefore, we can merge the vertices only, if we find a smart way</span>
        <span class="c1"># to keep the number of considered pairs small.</span>
        
        <span class="n">countVia</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#debug only</span>
        <span class="n">countNotLO</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#debug only</span>
        <span class="n">disorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">taskLength</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">disorder</span><span class="p">)</span>
        <span class="n">viaVertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sourceNumber</span><span class="p">,</span> <span class="n">sinkNumber</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">testing</span><span class="p">:</span>
            <span class="n">pathLengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pathLengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sourceNumber</span><span class="p">,</span> <span class="n">sinkNumber</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">viaVertexCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sourceNumber</span><span class="p">,</span> <span class="n">sinkNumber</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">inspectedRoutes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
        <span class="n">inspectionArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;inspection&quot;</span><span class="p">]</span>
        <span class="n">stationCombinations</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="n">viaCandidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pairData</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">viaData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">arr</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">pairData</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        
        <span class="n">const_args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> 
                      <span class="n">labelData</span><span class="p">,</span> <span class="n">viaData</span><span class="p">,</span> <span class="n">localOptimalityConstant</span><span class="p">,</span>
                      <span class="n">acceptionFactor</span><span class="p">,</span> <span class="n">rejectionFactor</span><span class="p">]</span>
        
        <span class="n">testing_no_joint_reject</span> <span class="o">=</span> <span class="s2">&quot;joint_reject&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span>
        <span class="n">testing_no_length_lookups</span> <span class="o">=</span> <span class="s2">&quot;reuse_queries&quot;</span> <span class="ow">in</span> <span class="n">testing_args</span>
        
        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="n">cpu_count</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_find_admissible_via_vertices</span><span class="p">,</span>
                              <span class="n">viaCandidates</span><span class="p">[</span><span class="n">disorder</span><span class="p">],</span>
                              <span class="n">disorder</span><span class="p">,</span>
                              <span class="n">repeat</span><span class="p">(</span><span class="n">testing_no_joint_reject</span><span class="p">),</span>
                              <span class="n">repeat</span><span class="p">(</span><span class="n">testing_no_length_lookups</span><span class="p">),</span>
                              <span class="n">tasklength</span><span class="o">=</span><span class="n">taskLength</span><span class="p">,</span>
                              <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">mapObj</span><span class="p">:</span>
                <span class="n">viaIndex</span><span class="p">,</span> <span class="n">sourceIndices</span><span class="p">,</span> <span class="n">sinkIndices</span><span class="p">,</span> <span class="n">pathLengthsTmp</span><span class="p">,</span> \
                                    <span class="n">res</span><span class="p">,</span> <span class="n">notLO</span> <span class="o">=</span> <span class="n">num</span>
                
                <span class="n">percentageDone</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">percentageDone</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentageDone</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">countVia</span> <span class="o">+=</span> <span class="n">res</span>
                <span class="n">countNotLO</span> <span class="o">+=</span> <span class="n">notLO</span>
                <span class="n">viaVertexCount</span><span class="p">[</span><span class="n">sourceIndices</span><span class="p">,</span> <span class="n">sinkIndices</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="n">testing</span><span class="p">:</span>
                    <span class="n">pathLengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pathLengthsTmp</span><span class="p">)</span>
                    <span class="k">continue</span>
                
                <span class="n">sourceInspections</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">:</span>
                                     <span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_find_inspection_spots</span><span class="p">(</span>
                                         <span class="n">viaIndex</span><span class="p">,</span> <span class="c1">#labelData[source][viaIndex][&quot;parent&quot;], </span>
                                         <span class="n">labelData</span><span class="p">[</span><span class="n">source</span><span class="p">],</span> 
                                         <span class="n">inspectionArr</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sourceIndices</span><span class="p">)}</span>
                <span class="n">sinkInspections</span> <span class="o">=</span> <span class="p">{</span><span class="n">sink</span><span class="p">:</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_find_inspection_spots</span><span class="p">(</span>
                                         <span class="n">viaIndex</span><span class="p">,</span> <span class="n">labelData</span><span class="p">[</span><span class="n">sink</span><span class="o">+</span><span class="n">sourceNumber</span><span class="p">],</span> 
                                         <span class="n">inspectionArr</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">sink</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sinkIndices</span><span class="p">)}</span>
                
                <span class="k">for</span> <span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">,</span> <span class="n">pathLength</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sourceIndices</span><span class="p">,</span> 
                                                              <span class="n">sinkIndices</span><span class="p">,</span> 
                                                              <span class="n">pathLengthsTmp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">pathLengths</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">]:</span>
                        <span class="n">viaVertices</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">viaIndex</span><span class="p">]</span>
                        <span class="n">pathLengths</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathLength</span><span class="p">]</span>
                        <span class="n">pathIndex</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="n">pathIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pathLengths</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">])</span>
                        <span class="n">viaVertices</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">viaIndex</span><span class="p">)</span>
                        <span class="n">pathLengths</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pathLength</span><span class="p">)</span> 
                    
                    <span class="n">stations</span> <span class="o">=</span> <span class="n">sourceInspections</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                                                    <span class="n">sinkInspections</span><span class="p">[</span><span class="n">sinkIndex</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">inspectionIndex</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
                        <span class="n">inspectedRoutes</span><span class="p">[</span><span class="n">inspectionIndex</span><span class="p">][</span>
                                <span class="p">(</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pathIndex</span><span class="p">)</span>
                    <span class="n">stationCombinations</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">stations</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                            <span class="p">(</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">,</span> <span class="n">pathIndex</span><span class="p">)</span>
                                                                    <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        <span class="n">startTime</span> <span class="o">=</span> <span class="n">endTime</span>
        <span class="n">endTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Checking the admissibility of the candidate vertices took </span><span class="si">{}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;In total, </span><span class="si">{}</span><span class="s2"> seconds elapsed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">endTime</span><span class="o">-</span><span class="n">startTimeTot</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
        
        <span class="k">if</span> <span class="n">testing</span><span class="p">:</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;mean paths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;median paths&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">thrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">):</span>
                <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;&gt; </span><span class="si">{}</span><span class="s2"> paths&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thrsh</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">viaVertexCount</span> <span class="o">&gt;</span> <span class="n">thrsh</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.01&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.02&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.03&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.04&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.05&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.10&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.30&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.70&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">70</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.90&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.95&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.96&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">96</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.97&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">97</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.98&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">98</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;pct 0.99&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;mean shortest dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;median shortest dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;mean dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pathLengths</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;median dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">pathLengths</span><span class="p">)</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;admissibility&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTime</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endTime</span><span class="o">-</span><span class="n">startTimeTot</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">][</span><span class="s2">&quot;mean paths&quot;</span><span class="p">]</span>
            <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;slowdown&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">testResults</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">][</span><span class="s2">&quot;shortest path&quot;</span><span class="p">]</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">testResults</span>
        
        
        <span class="c1"># because we excluded some via edges, it can theoretically happen that</span>
        <span class="c1"># some pairs have no via vertex at all. This should not be the case - </span>
        <span class="c1"># at least the shortest path should always be included. Therefore, we</span>
        <span class="c1"># have to consider this case separately, if necessary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pathLengths</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">dSources</span><span class="p">,</span> <span class="n">dSinks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">pathLengths</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not all pairs are connected. &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dSources</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">so</span><span class="p">,</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dSources</span><span class="p">,</span> <span class="n">dSinks</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disconnected:&quot;</span><span class="p">,</span> <span class="n">so</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sourceIndexToSourceID</span><span class="p">[</span><span class="n">so</span><span class="p">],</span>
                      <span class="n">si</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sinkIndexToSinkID</span><span class="p">[</span><span class="n">si</span><span class="p">],</span> <span class="n">dists</span><span class="p">[</span><span class="n">so</span><span class="p">,</span> <span class="n">si</span><span class="p">])</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            self.prst(&quot;Adding additional via vertex for not yet connected&quot;,</span>
<span class="sd">                      &quot;pairs.&quot;)</span>
<span class="sd">            raise NotImplementedError(&quot;Finding the inspection paths on a &quot; +</span>
<span class="sd">                                      &quot;shortest route has not been implemented&quot;,</span>
<span class="sd">                                      + &quot; yet because it seemed not to be &quot;</span>
<span class="sd">                                      + &quot; necessary. Obviously this is wrong...&quot;</span>
<span class="sd">                                      )</span>
<span class="sd">            for source, sink in zip(np.nonzero(~pathLengths.astype(bool))):</span>
<span class="sd">                pathLengths[source, sink] = [dists[source, sink]]</span>
<span class="sd">                # TODO</span>
<span class="sd">                # here I have to implement an inspection spot finder for the</span>
<span class="sd">                # shortest path</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="c1">#pathLengths[0,0]=0</span>
        <span class="n">pathLengths</span> <span class="o">=</span> <span class="n">csr_matrix_nd</span><span class="p">(</span><span class="n">pathLengths</span><span class="p">)</span>
        
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">countVia</span><span class="o">/</span><span class="p">(</span><span class="n">sourceNumber</span><span class="o">*</span><span class="n">sinkNumber</span><span class="p">),</span> <span class="s2">&quot;via vertices per pair&quot;</span><span class="p">)</span>     
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">countNotLO</span><span class="o">/</span><span class="p">(</span><span class="n">sourceNumber</span><span class="o">*</span><span class="n">sinkNumber</span><span class="p">),</span> <span class="s2">&quot;via vertices per pair were pruned because they were not locally optimal&quot;</span><span class="p">)</span>     
        <span class="n">minCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">)</span>
        <span class="n">maxCount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">viaVertexCount</span><span class="p">)</span>
        <span class="c1">#bins=maxCount-minCount</span>
        <span class="c1">#if bins:</span>
        <span class="c1">#    print(np.histogram(viaVertexCount, bins=bins))     </span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        def getVertexByID(ID, subset=None):</span>
<span class="sd">            if subset is None:</span>
<span class="sd">                return np.nonzero(self.vertices.array[&quot;ID&quot;]==ID)[0][0]</span>
<span class="sd">            return np.nonzero(self.vertices.array[&quot;ID&quot;][subset]==ID)[0][0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;done.&quot;</span><span class="p">)</span>       
        
        <span class="c1">#print(inspectedRoutes)</span>
        
        <span class="c1"># pathLengths is a 3D array that contains for each source-sink pair a</span>
        <span class="c1"># list (as a  sparse matrix) of the lengths of all paths that go from </span>
        <span class="c1"># the source to the sink</span>
        <span class="c1">#</span>
        <span class="c1"># inspectedRoutes is a dict that contains for each inspection station </span>
        <span class="c1"># (key) another dict with key source-sink pair and as value a list of </span>
        <span class="c1"># the indices of all paths that go through the inspection spot from the </span>
        <span class="c1"># source to the sink. The paths&#39;s index refers to its index in </span>
        <span class="c1"># pathLengths. That is, the lengths of the paths going from i to j </span>
        <span class="c1"># through spot s are given by </span>
        <span class="c1"># [pathLengths[i, j, p] for p in inspectedRoutes[s][i, j]]</span>
        <span class="c1">#</span>
        <span class="c1"># stationCombinations is a dictionary that contains frozen sets of </span>
        <span class="c1"># inspection stations as key and the flows that go exactly via these</span>
        <span class="c1"># sets of inspection stations as values - in form of a list of tuples</span>
        <span class="c1"># (sourceIndex, sinkIndex, flowIndex) (see above)</span>
        
        <span class="n">inspectedRoutes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">inspectedRoutes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inspectedRoutes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">inspectedRoutes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">pathLengths</span><span class="p">,</span> <span class="n">inspectedRoutes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stationCombinations</span><span class="p">)</span></div>
                
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_decrease_closest_source_distance</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">closestSourceDists</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">closestSourceDists</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">:</span>
                        <span class="n">closestSourceDists</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">closestSourceDists</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_grow_bounded_tree</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">,</span> <span class="n">lengthArr</span><span class="p">,</span> <span class="n">inspectionArr</span><span class="p">,</span>
                           <span class="n">stretchConstant</span><span class="p">,</span> <span class="n">localOptimalityConstant</span><span class="p">,</span> 
                           <span class="n">closestSourceDistCommunicator</span><span class="p">,</span> <span class="c1">#treeIndex, </span>
                           <span class="n">startIndex</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">shortestShortestDist</span><span class="p">,</span>
                           <span class="n">longestShortestDist</span><span class="p">,</span> <span class="n">naiveBound</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">naivePruning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">noBackwardPruning</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="p">):</span>
        
        <span class="n">edgesVisited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1">#tolerance = 1e-11</span>
        <span class="n">rTol</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="mf">1e-7</span>
        
        <span class="n">chunk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chunksize</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="k">if</span> <span class="n">forward</span><span class="p">:</span> 
            <span class="n">closestSourceQueue</span> <span class="o">=</span> <span class="n">closestSourceDistCommunicator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">closestSourceDists</span> <span class="o">=</span> <span class="n">closestSourceDistCommunicator</span>
        
        <span class="n">initSize</span> <span class="o">=</span> <span class="mi">25000</span>
        <span class="n">reachArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;reachBound&quot;</span><span class="p">]</span> 
        <span class="k">if</span> <span class="n">forward</span><span class="p">:</span> 
            <span class="n">neighborArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">neighborArr</span> <span class="o">=</span> <span class="n">vertexArr</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span>
        
        <span class="n">queue</span> <span class="o">=</span> <span class="n">intquickheapdict</span><span class="p">(((</span><span class="n">startIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span> <span class="n">initSize</span><span class="o">=</span><span class="n">initSize</span><span class="p">)</span>
        
        <span class="n">dataDtype</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;parent_inspection&quot;</span><span class="p">],</span>
                     <span class="s2">&quot;formats&quot;</span><span class="p">:[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">]}</span> 
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">FlexibleArrayDict</span><span class="p">(</span><span class="n">initSize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dataDtype</span><span class="p">)</span> 
        <span class="n">data</span><span class="p">[</span><span class="n">startIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">naiveBound</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">longestShortestDist</span> <span class="o">*</span> <span class="n">stretchConstant</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="n">longestShortestDist</span> <span class="o">*</span> <span class="n">stretchConstant</span> 
                     <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">localOptimalityConstant</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
            
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span> 
            <span class="n">thisVertex</span><span class="p">,</span> <span class="n">thisCost</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">naivePruning</span><span class="p">:</span>
                <span class="c1"># for testing only</span>
                <span class="n">pruned</span> <span class="o">=</span> <span class="p">(</span><span class="n">reachArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span> 
                          <span class="n">localOptimalityConstant</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thisCost</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pruned</span> <span class="o">=</span> <span class="p">(</span><span class="n">reachArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span> 
                          <span class="nb">min</span><span class="p">(</span><span class="n">thisCost</span><span class="p">,</span> <span class="n">localOptimalityConstant</span><span class="o">/</span><span class="mi">2</span> 
                              <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">thisCost</span><span class="p">,</span> <span class="n">shortestShortestDist</span><span class="p">)))</span>
            
            <span class="c1"># set the vertex information</span>
            <span class="c1"># However, we need only one overlapping vertex from the vertex </span>
            <span class="c1"># perspective. From the edge perspective we do need one overlapping</span>
            <span class="c1"># edge, too, but not both its end points.</span>
            <span class="c1"># therefore, we can save memory here by deleting the unnecessary</span>
            <span class="c1"># end point.</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;edge&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">edgesVisited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="sd">&quot;&quot;&quot; # uncomment this, if some vertices are not allowed to be </span>
<span class="sd">                # via vertices</span>
<span class="sd">            parent, edge, _, _ = data[thisVertex]</span>
<span class="sd">            if forward: </span>
<span class="sd">                if edge &gt;= 0 and potentialViaVertexArr[thisVertex]:</span>
<span class="sd">                    edgesVisited[edge] = True</span>
<span class="sd">            else:</span>
<span class="sd">                if edge &gt;= 0 and potentialViaVertexArr[parent]:</span>
<span class="sd">                    edgesVisited[edge] = True</span>
<span class="sd">            #vertexDists[thisVertex, treeIndex] = thisCost</span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">forward</span> <span class="ow">and</span> <span class="n">pruned</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;cost&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisCost</span>
                
                <span class="k">if</span> <span class="n">forward</span><span class="p">:</span> 
                    <span class="n">chunk</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">thisVertex</span><span class="p">,</span> <span class="n">thisCost</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">chunksize</span><span class="p">:</span>
                        <span class="n">closestSourceQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                        <span class="n">chunk</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="c1"># prune, if necessary</span>
                <span class="k">if</span> <span class="n">pruned</span><span class="p">:</span>
                    <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="ow">and</span> <span class="n">edge</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">inspection</span> <span class="o">=</span> <span class="n">thisVertex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inspection</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;parent_inspection&quot;</span><span class="p">]</span>
            
            <span class="c1"># the edge to this vertex must be considered (unless pruned)    </span>
            <span class="c1"># even if the vertex is farther away than the bound. However,</span>
            <span class="c1"># it does not need to be expanded.</span>
            <span class="k">if</span> <span class="n">thisCost</span> <span class="o">&gt;</span> <span class="n">bound</span><span class="p">:</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                if DEBUG2:</span>
<span class="sd">                    print(&quot;thisCost &gt; bound&quot;)</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">continue</span>
            
                
            <span class="c1"># process successors</span>
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">neighborArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1">#print(&quot;neighbor&quot;)</span>
                <span class="n">newCost</span> <span class="o">=</span> <span class="n">thisCost</span> <span class="o">+</span> <span class="n">lengthArr</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
                
                <span class="c1"># early pruning only from one side so that</span>
                <span class="c1"># paths are always closed. </span>
                <span class="c1"># Furthermore, there are no </span>
                <span class="c1"># lower distance bounds in forward direction</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">forward</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">naivePruning</span> <span class="ow">or</span> <span class="n">noBackwardPruning</span><span class="p">:</span>
                        <span class="n">pruned</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pruned</span> <span class="o">=</span> <span class="p">(</span><span class="n">reachArr</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">*</span><span class="n">rTol</span> <span class="o">&lt;</span>
                                  <span class="nb">min</span><span class="p">(</span><span class="n">newCost</span><span class="p">,</span> <span class="n">localOptimalityConstant</span><span class="o">/</span><span class="mi">2</span> 
                                      <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">newCost</span><span class="p">,</span> <span class="n">shortestShortestDist</span><span class="p">),</span>
                                      <span class="n">closestSourceDists</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]))</span>
                    
                    <span class="k">if</span> <span class="n">pruned</span><span class="p">:</span>
                        <span class="c1">#if reach &lt; thisCost: </span>
                        <span class="c1">#    break    # ! This must be deleted, because the neighbors have different distances to the sources.</span>
                        <span class="c1">#elif reach &lt; newCost:</span>
                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        if DEBUG2:</span>
<span class="sd">                            print(&quot;reach &lt; newCost and reach &lt; closestSourceDists[neighbor]&quot;,</span>
<span class="sd">                                  vertexArr[neighbor][&quot;ID&quot;])</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="k">continue</span>
                
                <span class="c1"># if not pruned</span>
                <span class="n">neighborCost</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">neighborCost</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># if neighbor is in the queue</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="n">neighborCost</span> <span class="o">&gt;</span> <span class="n">newCost</span><span class="o">*</span><span class="n">rTol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#check whether neighbor already scanned</span>
                    <span class="n">update</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span>
                
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                if DEBUG2:</span>
<span class="sd">                    print(&quot;Update&quot;, vertexArr[neighbor][&quot;ID&quot;], update, </span>
<span class="sd">                          neighborCost, newCost + tolerance, neighborCost-(newCost + tolerance))</span>
<span class="sd">                &quot;&quot;&quot;</span>
                
                <span class="c1"># reach &lt; thisCost is the weakened early pruning #?????</span>
                <span class="k">if</span> <span class="n">update</span><span class="p">:</span> <span class="c1"># and reach &gt;= thisCost: ????</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisVertex</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">inspection</span><span class="p">)</span>
                    <span class="n">queue</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">newCost</span>
            
        <span class="k">if</span> <span class="n">forward</span><span class="p">:</span>
            <span class="n">closestSourceQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">cut</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">edgesVisited</span> 
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        j = 0</span>
<span class="sd">        for i in range(10000000000):</span>
<span class="sd">            j = i</span>
<span class="sd">        print(&quot;done2&quot;)</span>
<span class="sd">        return 0, 0</span>
<span class="sd">    #&quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_edge_superneighbours</span><span class="p">(</span><span class="n">edgeVisitedSources</span><span class="p">,</span> <span class="n">edgeVisitedSinks</span><span class="p">,</span>
                                   <span class="n">edgeIndex</span><span class="p">,</span> <span class="n">predecessorEdges</span><span class="p">,</span> <span class="n">successorEdges</span><span class="p">):</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we disregard empty sets, we know that each edge has at most</span>
<span class="sd">        one superset or subset for each predecessor or successor.</span>
<span class="sd">        Here we determine the respective neighbour edges. If there is</span>
<span class="sd">        a superset neighbour, we know that the respective edge is no plateau</span>
<span class="sd">        peak. Hence, _find_edge_superneighbours returns None.</span>
<span class="sd">        Otherwise, _find_edge_superneighbours returns the indices of the edges</span>
<span class="sd">        (predecessor, successor) that have the same set of sources and sinks.</span>
<span class="sd">        If there is no such predecessor or successore, the entry is None</span>
<span class="sd">        respectively. For example, direct plateau peaks have only strict subsets</span>
<span class="sd">        and will return (None, None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">sources</span><span class="p">,</span> <span class="n">sinks</span> <span class="o">=</span> <span class="n">edgeVisitedSources</span><span class="p">[</span><span class="n">edgeIndex</span><span class="p">],</span> <span class="n">edgeVisitedSinks</span><span class="p">[</span><span class="n">edgeIndex</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">neighborEdgeIndex</span> <span class="ow">in</span> <span class="n">predecessorEdges</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># recall that each edge in edgeVisitedSinks is also in </span>
            <span class="c1"># edgeVisitedSources by construction</span>
            <span class="k">if</span> <span class="n">neighborEdgeIndex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edgeVisitedSources</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">neighborSources</span> <span class="o">=</span> <span class="n">edgeVisitedSources</span><span class="p">[</span><span class="n">neighborEdgeIndex</span><span class="p">]</span>
            <span class="n">neighborSinks</span> <span class="o">=</span> <span class="n">edgeVisitedSinks</span><span class="p">[</span><span class="n">neighborEdgeIndex</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sources</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">neighborSources</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sinks</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">neighborSinks</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">neighborSources</span> <span class="o">==</span> <span class="n">sources</span> <span class="ow">and</span> <span class="n">neighborSinks</span> <span class="o">==</span> <span class="n">sinks</span><span class="p">:</span>
                    <span class="n">predecessor</span> <span class="o">=</span> <span class="n">neighborEdgeIndex</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predecessor</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">for</span> <span class="n">neighborEdgeIndex</span> <span class="ow">in</span> <span class="n">successorEdges</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># recall that each edge in edgeVisitedSinks is also in </span>
            <span class="c1"># edgeVisitedSources by construction</span>
            <span class="k">if</span> <span class="n">neighborEdgeIndex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edgeVisitedSources</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">neighborSources</span> <span class="o">=</span> <span class="n">edgeVisitedSources</span><span class="p">[</span><span class="n">neighborEdgeIndex</span><span class="p">]</span>
            <span class="n">neighborSinks</span> <span class="o">=</span> <span class="n">edgeVisitedSinks</span><span class="p">[</span><span class="n">neighborEdgeIndex</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sources</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">neighborSources</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sinks</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">neighborSinks</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">neighborSources</span> <span class="o">==</span> <span class="n">sources</span> <span class="ow">and</span> <span class="n">neighborSinks</span> <span class="o">==</span> <span class="n">sinks</span><span class="p">:</span>
                    <span class="n">successor</span> <span class="o">=</span> <span class="n">neighborEdgeIndex</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">successor</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">return</span> <span class="n">predecessor</span><span class="p">,</span> <span class="n">successor</span>
            
    <span class="k">def</span> <span class="nf">_find_plateau_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidateEdges</span><span class="p">,</span> <span class="n">edgesVisitedSources</span><span class="p">,</span>
                            <span class="n">edgesVisitedSinks</span><span class="p">):</span>
        
        <span class="n">successorArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;successors&quot;</span><span class="p">]</span> 
        <span class="n">predecessorArr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;predecessors&quot;</span><span class="p">]</span> 
        
        <span class="n">vertexFromIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;fromIndex&quot;</span><span class="p">]</span>
        <span class="n">vertexToIndices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;toIndex&quot;</span><span class="p">]</span>
        
        
        <span class="n">plateauPeaks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unprocessedCandidates</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Searching for plateau peak edges. (</span><span class="si">{}</span><span class="s2"> candidates)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                           <span class="nb">len</span><span class="p">(</span><span class="n">candidateEdges</span><span class="p">)))</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_print_level</span><span class="p">()</span>
        
        <span class="n">taskLength</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgesVisitedSinks</span><span class="p">)</span>
        <span class="n">const_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">edgesVisitedSources</span><span class="p">,</span> <span class="n">edgesVisitedSinks</span><span class="p">)</span>
        
        <span class="n">printCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidateEdges</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
        

        <span class="k">with</span> <span class="n">ProcessPoolExecutor_ext</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">const_args</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">mapObj</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">FlowPointGraph</span><span class="o">.</span><span class="n">_find_edge_superneighbours</span><span class="p">,</span>
                              <span class="n">candidateEdges</span><span class="p">,</span>
                              <span class="n">predecessorArr</span><span class="p">[</span><span class="n">vertexFromIndices</span><span class="p">[</span><span class="n">candidateEdges</span><span class="p">]],</span> 
                              <span class="n">successorArr</span><span class="p">[</span><span class="n">vertexToIndices</span><span class="p">[</span><span class="n">candidateEdges</span><span class="p">]],</span> 
                              <span class="n">tasklength</span><span class="o">=</span><span class="n">taskLength</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edgeIndex</span><span class="p">,</span> <span class="n">neighborTuple</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidateEdges</span><span class="p">,</span> <span class="n">mapObj</span><span class="p">):</span>
                <span class="n">percentageDone</span> <span class="o">=</span> <span class="n">printCounter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">percentageDone</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="n">percentageDone</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">neighborTuple</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># this edge has a superset neighbour</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">neighborTuple</span> <span class="o">==</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># this edge is known to be a plateau peak</span>
                    <span class="n">plateauPeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edgeIndex</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">unprocessedCandidates</span><span class="p">[</span><span class="n">edgeIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighborTuple</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Traversing the graph.&quot;</span><span class="p">)</span>
        <span class="n">noNeighbour</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">unprocessedCandidates</span><span class="p">:</span>
            <span class="n">edgeIndex</span><span class="p">,</span> <span class="n">neighborTuple</span> <span class="o">=</span> <span class="n">unprocessedCandidates</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
            <span class="n">predecessorIndex</span><span class="p">,</span> <span class="n">successorIndex</span> <span class="o">=</span> <span class="n">neighborTuple</span>
            
            <span class="c1"># traverse predecessors and successors of plateaus</span>
            <span class="c1"># until either no superset is found (index is None) or there is an </span>
            <span class="c1"># index that has already been discarded because it is known to be </span>
            <span class="c1"># no plateau peak (then the entry is missing). </span>
            <span class="k">while</span> <span class="n">predecessorIndex</span> <span class="ow">or</span> <span class="p">(</span><span class="n">predecessorIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                                       <span class="n">predecessorIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">predecessorIndex</span> <span class="o">=</span> <span class="n">unprocessedCandidates</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">predecessorIndex</span><span class="p">,</span> 
                                                             <span class="n">noNeighbour</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">predecessorIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">while</span> <span class="n">successorIndex</span> <span class="ow">or</span> <span class="p">(</span><span class="n">successorIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                                     <span class="n">successorIndex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">successorIndex</span> <span class="o">=</span> <span class="n">unprocessedCandidates</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">successorIndex</span><span class="p">,</span> 
                                                           <span class="n">noNeighbour</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">successorIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plateauPeaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edgeIndex</span><span class="p">)</span>
                
            
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_print_level</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prst</span><span class="p">(</span><span class="s2">&quot;Found&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">plateauPeaks</span><span class="p">)</span> <span class="p">,</span><span class="s2">&quot;plateau peak edges.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plateauPeaks</span><span class="p">)</span>

        
        
                
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    @staticmethod</span>
<span class="sd">    def _get_edge_source_sink_distances(fbLabelData, edgesVisitedArray, </span>
<span class="sd">                                        vertexIndex):</span>
<span class="sd">        </span>
<span class="sd">        return [(labelData[vertexIndex][&quot;cost&quot;] if visited else np.nan)</span>
<span class="sd">                for labelData, visited in zip(fbLabelData, edgesVisitedArray)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_edge_source_sink_distances</span><span class="p">(</span><span class="n">fbLabelData</span><span class="p">,</span> <span class="n">edgeVisitedSources</span><span class="p">,</span> 
                                        <span class="n">edgeVisitedSinks</span><span class="p">,</span> 
                                        <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">sourceNo</span><span class="p">,</span> <span class="n">sinkNo</span><span class="p">):</span>
        <span class="n">resultSources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sourceNo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">resultSinks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">sinkNo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">edgeVisitedSources</span><span class="p">:</span>
            <span class="n">resultSources</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">fbLabelData</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">][</span><span class="s2">&quot;cost&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">edgeVisitedSinks</span><span class="p">:</span>
            <span class="n">resultSinks</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">fbLabelData</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="n">sourceNo</span><span class="p">][</span><span class="n">vertexIndex</span><span class="p">][</span><span class="s2">&quot;cost&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">resultSources</span><span class="p">,</span> <span class="n">resultSinks</span>
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_vertex_source_sink_distances</span><span class="p">(</span><span class="n">fbLabelData</span><span class="p">,</span> <span class="n">vertexIndex</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="p">[(</span><span class="n">labelData</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">labelData</span><span class="o">.</span><span class="n">indexDict</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]][</span><span class="s2">&quot;cost&quot;</span><span class="p">]</span>
                 <span class="k">if</span> <span class="n">vertexIndex</span> <span class="ow">in</span> <span class="n">labelData</span><span class="o">.</span><span class="n">indexDict</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">labelData</span> <span class="ow">in</span> <span class="n">fbLabelData</span><span class="p">]</span>
    
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_vertexCandidates</span><span class="p">(</span><span class="n">shortestDistances</span><span class="p">,</span> <span class="n">sourceDistances</span><span class="p">,</span> <span class="n">sinkDistances</span><span class="p">,</span> 
                               <span class="n">stretchConstant</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">roundNo</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span> <span class="o">=</span> <span class="n">pair</span>
        <span class="n">viaDistances</span> <span class="o">=</span> <span class="n">sourceDistances</span><span class="p">[:,</span><span class="n">sourceIndex</span><span class="p">]</span><span class="o">+</span><span class="n">sinkDistances</span><span class="p">[:,</span><span class="n">sinkIndex</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">viaDistanceIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">viaDistances</span> <span class="o">&lt;=</span> 
                <span class="n">shortestDistances</span><span class="p">[</span><span class="n">sourceIndex</span><span class="p">,</span> <span class="n">sinkIndex</span><span class="p">]</span><span class="o">*</span><span class="n">stretchConstant</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">viaDistances</span><span class="p">[</span><span class="n">viaDistanceIndices</span><span class="p">]</span>
        
        <span class="c1"># only for testing purposes we may want to return the same path multiple </span>
        <span class="c1"># times</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">candidates</span><span class="p">[</span><span class="n">viaDistanceIndices</span><span class="p">],</span> <span class="n">lengths</span>
            
        <span class="n">lengths</span><span class="p">,</span> <span class="n">candidateIndices</span> <span class="o">=</span> <span class="n">unique_tol</span><span class="p">(</span>
            <span class="n">round_rel</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">roundNo</span><span class="p">),</span> 
            <span class="n">round_rel</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">roundNo</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="n">lengths</span>
            <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">candidates</span><span class="p">[</span><span class="n">viaDistanceIndices</span><span class="p">[</span><span class="n">candidateIndices</span><span class="p">]],</span> <span class="n">lengths</span>
        
    
    
    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_admissible_via_vertices</span><span class="p">(</span>
            <span class="n">vertexArr</span><span class="p">,</span> <span class="n">edgeArr</span><span class="p">,</span> <span class="n">shortestDistances</span><span class="p">,</span> <span class="n">labelData</span><span class="p">,</span> <span class="n">viaData</span><span class="p">,</span>
            <span class="n">localOptimalityConstant</span><span class="p">,</span> <span class="n">acceptionFactor</span><span class="p">,</span> <span class="n">rejectionFactor</span><span class="p">,</span>
            <span class="n">vertexIndex</span><span class="p">,</span> <span class="n">viaIndex</span><span class="p">,</span> <span class="n">testing_no_joint_reject</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">testing_no_length_lookups</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        vertexArr</span>
<span class="sd">                    Structured Array with the vertex information. Indexed by </span>
<span class="sd">                    vertexIndex</span>
<span class="sd">        edgeArr</span>
<span class="sd">                    Structured Array with the edge information. Indexed by </span>
<span class="sd">                    edgeIndex</span>
<span class="sd">        shortestDistances</span>
<span class="sd">                    2D double Array; has at [i,j] the distance from source i to </span>
<span class="sd">                    sink j</span>
<span class="sd">                    i,j:    are the index of the source/sink in their </span>
<span class="sd">                            respective lists and NOT the vertexIndices of the </span>
<span class="sd">                            respective vertices!</span>
<span class="sd">        labelData</span>
<span class="sd">                    list of FlexibleArrayDicts </span>
<span class="sd">                    with fields [&quot;parent&quot;, &quot;edge&quot;, &quot;cost&quot;];</span>
<span class="sd">                    has at [i][j] the distance of vertex j to source/sink i</span>
<span class="sd">                    i:      number of the via vertex, NOT its vertex index</span>
<span class="sd">                    j:      index of the source/sink in the source/sink list. </span>
<span class="sd">                            NOT the vertex index!</span>
<span class="sd">                            If j is a sink, then the index in the sink list is</span>
<span class="sd">                            given by j-SourceNumber</span>
<span class="sd">        localOptimalityConstant</span>
<span class="sd">                    search parameter</span>
<span class="sd">        acceptionFactor, rejectionFactor</span>
<span class="sd">                    determie the precision of the results. Paths with local </span>
<span class="sd">                    optimality above localOptimalityConstant*acceptFactor might </span>
<span class="sd">                    be accepted. Local optimal paths with local optimality below</span>
<span class="sd">                    localOptimalityConstant*rejectFactor might be rejected.</span>
<span class="sd">                    Perfect results are obtained with the values being (1, 1)</span>
<span class="sd">                    A 2-approximation can be obtained with the values (2/3, 4/3)</span>
<span class="sd">        candidateIndex</span>
<span class="sd">                    number of the via vertex (NOT its vertex index) that is to</span>
<span class="sd">                    be checked for admissibility w.r.t. all source/sink pairs</span>
<span class="sd">        vertexIndex</span>
<span class="sd">                    vertex index of the vertex that is to</span>
<span class="sd">                    be checked for admissibility w.r.t. all source/sink pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rTol</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">rTolFact</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">rTol</span>
        
        <span class="c1">#========= Performing T-Tests ==========================================</span>
        
        <span class="c1"># save the pair data in a convenient way</span>
        <span class="n">pairList</span> <span class="o">=</span> <span class="n">viaData</span><span class="p">[</span><span class="n">viaIndex</span><span class="p">]</span>
            
        <span class="n">sourceNumber</span><span class="p">,</span> <span class="n">sinkNumber</span> <span class="o">=</span> <span class="n">shortestDistances</span><span class="o">.</span><span class="n">shape</span>
        
        <span class="c1"># get the original indices of the sources and sinks</span>
        <span class="n">consideredSourceIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">])</span>
        <span class="c1"># for the sinks we add the sourceNumber, so that we reach the correct</span>
        <span class="c1"># entry in the labelData</span>
        <span class="n">consideredSinkIndices_plain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">])</span>
        <span class="n">consideredSinkIndices</span> <span class="o">=</span> <span class="n">consideredSinkIndices_plain</span> <span class="o">+</span> <span class="n">sourceNumber</span>
        
        <span class="n">consideredSources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">consideredSourceIndices</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">consideredSinks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">consideredSinkIndices</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        
        
        <span class="n">sourceIndexToSource</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sourceNumber</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">sourceIndexToSource</span><span class="p">[</span><span class="n">consideredSourceIndices</span><span class="p">]</span> <span class="o">=</span> <span class="n">consideredSources</span>
        <span class="n">sinkIndexToSink</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sinkNumber</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">sinkIndexToSink</span><span class="p">[</span><span class="n">consideredSinkIndices_plain</span><span class="p">]</span> <span class="o">=</span> <span class="n">consideredSinks</span>
        
        <span class="n">shortestDistances</span> <span class="o">=</span> <span class="n">shortestDistances</span><span class="p">[</span><span class="n">consideredSourceIndices</span><span class="p">][:,</span><span class="n">consideredSinkIndices_plain</span><span class="p">]</span>
        
        <span class="c1"># replace source and sink indices in pairList with internal indices</span>
        <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sourceIndexToSource</span><span class="p">[</span><span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]]</span>
        <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sinkIndexToSink</span><span class="p">[</span><span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]]</span>
        
        <span class="c1"># distances[i,j] contains the distance of the via path from source i</span>
        <span class="c1"># to sink j</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">consideredSources</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> 
                                          <span class="n">consideredSinks</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        
        <span class="n">distances</span><span class="p">[</span><span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">],</span> <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ISNAN0&quot;</span><span class="p">,</span> <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;distance&quot;</span><span class="p">],</span> <span class="n">pairList</span><span class="p">)</span>
        
        <span class="n">admissiblePairs</span> <span class="o">=</span> <span class="o">~</span><span class="n">distances</span><span class="o">.</span><span class="n">mask</span>
        
        <span class="n">sourcePairIndices</span><span class="p">,</span> <span class="n">sinkPairIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span>
                                                <span class="p">)</span>
        <span class="n">pairList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
        
        
        <span class="n">vertexVisitedFromSource</span> <span class="o">=</span> <span class="n">FlexibleArrayDict</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> 
                                                     <span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                     <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">vertexVisitedFromSink</span> <span class="o">=</span> <span class="n">FlexibleArrayDict</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span> <span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> 
                                                   <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        
        <span class="c1"># note for each sink the maximal distance of a pair involving it</span>
        <span class="n">maxPairDistSinks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">maxPairDistSinks</span> <span class="o">=</span> <span class="n">maxPairDistSinks</span><span class="p">[</span><span class="o">~</span><span class="n">maxPairDistSinks</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        <span class="c1"># do the same for each source</span>
        <span class="n">maxPairDistSources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">maxPairDistSources</span> <span class="o">=</span> <span class="n">maxPairDistSources</span><span class="p">[</span><span class="o">~</span><span class="n">maxPairDistSources</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
        
        <span class="n">reverseSourceLabelData</span> <span class="o">=</span> <span class="p">{}</span>
 
        <span class="c1"># for each source and sink, mark all vertices visited on the way to</span>
        <span class="c1"># the respective end point as visited</span>
        <span class="k">for</span> <span class="n">endPoints</span><span class="p">,</span> <span class="n">endPointIndices</span><span class="p">,</span> <span class="n">maxPairDist</span><span class="p">,</span> <span class="n">visitedArr</span><span class="p">,</span> <span class="n">rSLD</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">consideredSources</span><span class="p">,</span> <span class="n">consideredSourceIndices</span><span class="p">,</span> 
                 <span class="n">maxPairDistSources</span><span class="p">,</span> <span class="n">vertexVisitedFromSource</span><span class="p">,</span>
                 <span class="n">reverseSourceLabelData</span><span class="p">),</span>
                <span class="p">(</span><span class="n">consideredSinks</span><span class="p">,</span> <span class="n">consideredSinkIndices</span><span class="p">,</span> 
                 <span class="n">maxPairDistSinks</span><span class="p">,</span> <span class="n">vertexVisitedFromSink</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                                       <span class="p">):</span>
            <span class="c1">#visitedArr[vertexIndex] = False</span>
            <span class="k">for</span> <span class="n">endPoint</span><span class="p">,</span> <span class="n">maxDist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">endPoints</span><span class="p">,</span> <span class="n">maxPairDist</span><span class="p">):</span>
                <span class="n">thisLabelData</span> <span class="o">=</span> <span class="n">labelData</span><span class="p">[</span><span class="n">endPointIndices</span><span class="p">[</span><span class="n">endPoint</span><span class="p">]]</span>
                <span class="n">maxDist</span> <span class="o">=</span> <span class="n">localOptimalityConstant</span> <span class="o">*</span> <span class="n">maxDist</span>
                <span class="n">thisVertex</span> <span class="o">=</span> <span class="n">vertexIndex</span>
                <span class="n">parent</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">thisLabelData</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span>
                <span class="n">stopCost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">-</span> <span class="n">maxDist</span>
                <span class="c1">#visitedArr[thisVertex][endPoint] = True</span>
                
                <span class="k">if</span> <span class="n">rSLD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">reverseData</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">rSLD</span><span class="p">[</span><span class="n">endPoint</span><span class="p">]</span> <span class="o">=</span> <span class="n">reverseData</span>
                <span class="k">while</span> <span class="n">cost</span> <span class="o">&gt;=</span> <span class="n">stopCost</span> <span class="ow">and</span> <span class="n">thisVertex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">parent</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">thisLabelData</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">thisVertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visitedArr</span><span class="p">:</span>
                        <span class="n">visitedArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">visitedArr</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="n">endPoint</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    
                    <span class="k">if</span> <span class="n">rSLD</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">reverseData</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisVertex</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
                    <span class="n">thisVertex</span> <span class="o">=</span> <span class="n">parent</span>
        
        <span class="n">sourcePointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">vertexIndex</span><span class="p">)</span>
        
        <span class="c1"># Dict that contains all the pairs for which we have confirmed that </span>
        <span class="c1"># the subpath between them is locally optimal </span>
        <span class="c1"># Key: test vertex on the sink branch</span>
        <span class="c1"># Value: set(tuple(test partner on source branch, </span>
        <span class="c1">#                    its predecessor (w.r.t. v)))</span>
        <span class="n">successfullyTested</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">set</span><span class="p">())</span>
        
        <span class="n">resultSourceIndices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">resultSinkIndices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">resultLengths</span> <span class="o">=</span> <span class="p">[]</span>
        
                           
        
        <span class="c1"># now check all pairs for their admissibility</span>
        <span class="n">sourceSinkIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">sourceList</span> <span class="o">=</span> <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
        <span class="n">sinkList</span> <span class="o">=</span> <span class="n">pairList</span><span class="p">[</span><span class="s2">&quot;sink&quot;</span><span class="p">]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># if we have already found out that we do not have to consider the</span>
            <span class="c1"># pair (anymore), continue</span>
            <span class="n">sourceSinkIndex</span> <span class="o">=</span> <span class="n">find_next_nonzero2d</span><span class="p">(</span><span class="n">admissiblePairs</span><span class="p">,</span> <span class="n">sourceList</span><span class="p">,</span>
                                                  <span class="n">sinkList</span><span class="p">,</span> <span class="n">sourceSinkIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">sourceSinkIndex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">pairList</span><span class="p">[</span><span class="n">sourceSinkIndex</span><span class="p">]</span>
            
            <span class="n">sourceLabelData</span> <span class="o">=</span> <span class="n">labelData</span><span class="p">[</span><span class="n">consideredSourceIndices</span><span class="p">[</span><span class="n">source</span><span class="p">]]</span>
            <span class="n">sinkLabelData</span> <span class="o">=</span> <span class="n">labelData</span><span class="p">[</span><span class="n">consideredSinkIndices</span><span class="p">[</span><span class="n">sink</span><span class="p">]]</span>
            <span class="n">thisReverseSourceLabelData</span> <span class="o">=</span> <span class="n">reverseSourceLabelData</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            
            <span class="c1"># T is the local optimal length</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">localOptimalityConstant</span> <span class="o">*</span> <span class="n">dist</span>
            
            <span class="n">extT</span> <span class="o">=</span> <span class="n">rejectionFactor</span> <span class="o">*</span> <span class="n">T</span>
            
            
            <span class="c1"># baseCostSink is the cost of the via vertex from the sink </span>
            <span class="n">parent</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">baseCostSink</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sinkLabelData</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">baseCostSource</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sourceLabelData</span><span class="p">[</span><span class="n">vertexIndex</span><span class="p">]</span>
            
            <span class="c1"># if the via vertex is an end vertex of the total path,</span>
            <span class="c1"># it is locally optimal, if the via cost is equal the shortest cost</span>
            <span class="c1"># (note that the via vertex is just the end point of the actual      NO A via edge must be scanned from both direction. Hence, only the shortest path will be used.</span>
            <span class="c1"># via edge - therefore, the via cost can be higher than the actual</span>
            <span class="c1"># cost to the end point) or not locally optimal (because we are </span>
            <span class="c1"># guaranteed that pruning does not lead to wrong results for </span>
            <span class="c1"># sufficiently locally optimal paths. However, we obtained that the</span>
            <span class="c1"># end vertex will be reached with too high cost, which is a wring </span>
            <span class="c1"># result. Therefore, the via path cannot be locally optimal.</span>
            <span class="c1"># We only have to compare the costs</span>
            <span class="k">if</span> <span class="n">baseCostSink</span> <span class="o">&lt;=</span> <span class="n">rTol</span> <span class="ow">or</span> <span class="n">baseCostSource</span> <span class="o">&lt;=</span> <span class="n">rTol</span><span class="p">:</span>
                <span class="c1">#if np.isclose(dist, shortestDistances[source, sink], rTol):</span>
                <span class="n">resultSourceIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">resultSinkIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sink</span><span class="p">)</span>
                <span class="n">resultLengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                
                <span class="k">continue</span>
            
            
            <span class="c1"># go to the x_T vertex (farthest vertex within the test range)</span>
            <span class="c1"># (this could be sped up, if necessary)</span>
            <span class="n">thisSourceVertex</span> <span class="o">=</span> <span class="n">sourcePointers</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="n">sourceParent</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sourceCost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sourceLabelData</span><span class="p">[</span><span class="n">thisSourceVertex</span><span class="p">]</span>
            <span class="n">sourceParentTmp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sourceCostParent</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sourceLabelData</span><span class="p">[</span>
                                                                 <span class="n">sourceParent</span><span class="p">]</span>
            <span class="n">stopCost</span> <span class="o">=</span> <span class="n">baseCostSource</span> <span class="o">-</span> <span class="n">T</span>
            
            <span class="c1"># note: I want to know the farthest vertex in T-Range and then</span>
            <span class="c1"># use its parent for the test</span>
            <span class="k">while</span> <span class="n">sourceCostParent</span> <span class="o">&gt;=</span> <span class="n">stopCost</span> <span class="ow">and</span> <span class="n">sourceParentTmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">thisSourceVertex</span> <span class="o">=</span> <span class="n">sourceParent</span>
                <span class="n">sourceParent</span> <span class="o">=</span> <span class="n">sourceParentTmp</span>
                <span class="n">sourceCost</span> <span class="o">=</span> <span class="n">sourceCostParent</span>
                <span class="n">sourceParentTmp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sourceCostParent</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sourceLabelData</span><span class="p">[</span>
                                                                <span class="n">sourceParent</span><span class="p">]</span>
            
            <span class="c1"># Note the source branch end of the considered subpath</span>
            <span class="n">sourceSubpathBound</span> <span class="o">=</span> <span class="n">sourceParent</span>
            <span class="n">sinkSubpathBound</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="c1"># Due to our skewed graph we have some very long edges. We do not</span>
            <span class="c1"># want them to interfere with the local optimality checks.</span>
            <span class="k">if</span> <span class="n">sourceCost</span> <span class="o">-</span> <span class="n">sourceCostParent</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">T</span><span class="p">:</span>
                <span class="n">sourceParent</span> <span class="o">=</span> <span class="n">thisSourceVertex</span>
                <span class="c1">#thisSourceVertex = thisSourceChield</span>
                <span class="n">sourceCostParent</span> <span class="o">=</span> <span class="n">sourceCost</span>
            
            
            <span class="c1"># update the source pointer</span>
            <span class="n">sourcePointers</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">thisSourceVertex</span>
            
            <span class="c1"># Do the T-Tests</span>
            <span class="n">sinkCost</span> <span class="o">=</span> <span class="n">baseCostSink</span>
            <span class="n">started</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># necessary in case the first check vertex is a </span>
                            <span class="c1"># direct neighbor of the via vertex</span>
            <span class="n">thisSinkVertex</span> <span class="o">=</span> <span class="n">vertexIndex</span>
            <span class="n">sinkParent</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sinkCost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sinkLabelData</span><span class="p">[</span><span class="n">thisSinkVertex</span><span class="p">]</span>
            
            
            <span class="k">while</span> <span class="n">sourceCostParent</span> <span class="o">&lt;</span> <span class="n">baseCostSource</span> <span class="ow">and</span> <span class="n">sinkSubpathBound</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                
                <span class="c1"># find the partner vertex on the sink branch</span>
                <span class="n">sinkCostOld</span> <span class="o">=</span> <span class="n">sinkCost</span>
                
                <span class="c1"># Possible optimization: if stopCost &lt;= 0, we could set the</span>
                <span class="c1"># sinkParent to the sink right away and save some interations.</span>
                
                <span class="c1"># we do not have to go further than T away from the via </span>
                <span class="c1"># vertex</span>
                <span class="n">stopCost</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">baseCostSink</span> <span class="o">+</span> <span class="n">baseCostSource</span> 
                               <span class="o">-</span> <span class="n">sourceCost</span> <span class="o">-</span> <span class="n">extT</span><span class="p">,</span> <span class="n">baseCostSink</span> <span class="o">-</span> <span class="n">T</span><span class="p">)</span>
                <span class="c1"># needed because we can use previous results only if the </span>
                <span class="c1"># distance is sufficiently large</span>
                <span class="n">minStopCost</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">baseCostSink</span> <span class="o">+</span> <span class="n">baseCostSource</span> 
                                  <span class="o">-</span> <span class="n">sourceCost</span> <span class="o">-</span> <span class="n">T</span><span class="p">,</span> <span class="n">baseCostSink</span> <span class="o">-</span> <span class="n">T</span><span class="p">)</span>
                <span class="n">sinkParentTmp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sinkCostParent</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
                                                <span class="n">sinkLabelData</span><span class="p">[</span><span class="n">sinkParent</span><span class="p">]</span>
                <span class="c1"># we might be able to exploit earlier tests</span>
                <span class="n">sourceParentTested</span> <span class="o">=</span> <span class="n">successfullyTested</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sourceParent</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">alreadyTested</span> <span class="o">=</span> <span class="kc">False</span>
                
                <span class="k">if</span> <span class="n">sinkCostParent</span> <span class="o">&gt;=</span> <span class="n">stopCost</span> <span class="ow">and</span> <span class="n">sinkParentTmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">while</span> <span class="n">sinkCostParent</span> <span class="o">&gt;=</span> <span class="n">stopCost</span> <span class="ow">and</span> <span class="n">sinkParentTmp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">thisSinkVertex</span> <span class="o">=</span> <span class="n">sinkParent</span>
                        <span class="n">sinkParent</span> <span class="o">=</span> <span class="n">sinkParentTmp</span>
                        <span class="n">sinkCost</span> <span class="o">=</span> <span class="n">sinkCostParent</span>
                        <span class="n">sinkParentTmp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sinkCostParent</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sinkLabelData</span><span class="p">[</span>
                                                                    <span class="n">sinkParent</span><span class="p">]</span>
                        
                        
                        <span class="c1"># if we know that the path between sourceParent and </span>
                        <span class="c1"># sinkParent is a shortest paht, then we can skip a shortest</span>
                        <span class="c1"># path query</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">sinkCostParent</span> <span class="o">&lt;=</span> <span class="n">minStopCost</span> <span class="ow">and</span> <span class="n">sourceParentTested</span> 
                                <span class="ow">and</span> <span class="n">sinkParent</span> <span class="ow">in</span> <span class="n">sourceParentTested</span><span class="p">):</span>
                            <span class="n">alreadyTested</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                <span class="k">elif</span> <span class="n">sourceParentTested</span> <span class="ow">and</span> <span class="n">sinkParent</span> <span class="ow">in</span> <span class="n">sourceParentTested</span><span class="p">:</span>
                    <span class="n">alreadyTested</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="c1"># Again: Due to our skewed graph we have some very long  </span>
                <span class="c1"># edges. We do not want them to interfere with the local </span>
                <span class="c1"># optimality checks.</span>
                <span class="k">if</span> <span class="n">sinkCost</span> <span class="o">-</span> <span class="n">sinkCostParent</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">T</span><span class="p">:</span>
                    <span class="n">sinkSubpathBound</span> <span class="o">=</span> <span class="n">sinkParent</span>
                    <span class="n">sinkParent</span> <span class="o">=</span> <span class="n">thisSinkVertex</span>
                    <span class="n">sinkCostParent</span> <span class="o">=</span> <span class="n">sinkCost</span>
                
                <span class="c1"># if a step has been done, </span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">alreadyTested</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sinkCostOld</span> <span class="o">==</span> <span class="n">sinkCost</span> 
                                          <span class="ow">or</span> <span class="n">started</span><span class="p">):</span>
                    <span class="n">started</span> <span class="o">=</span> <span class="kc">False</span>
                    
                    <span class="n">compCost</span> <span class="o">=</span> <span class="p">(</span><span class="n">baseCostSink</span> <span class="o">+</span> <span class="n">baseCostSource</span> 
                                <span class="o">-</span> <span class="n">sinkCostParent</span> <span class="o">-</span> <span class="n">sourceCostParent</span><span class="p">)</span>
                        
                    <span class="c1"># if considered section is shortest path</span>
                    <span class="c1">#if (localDistBound + aTol &gt;= compCost or </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">find_shortest_distance</span><span class="p">(</span><span class="n">vertexArr</span><span class="p">,</span> <span class="n">edgeArr</span><span class="p">,</span> 
                                               <span class="n">sourceParent</span><span class="p">,</span> <span class="n">sinkParent</span><span class="p">)</span>
                         <span class="o">*</span> <span class="n">rTolFact</span> <span class="o">&gt;=</span> <span class="n">compCost</span><span class="p">):</span>
                        <span class="c1">#if localDist + aTol &gt;= compCost:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">testing_no_length_lookups</span><span class="p">:</span>
                            <span class="n">successfullyTested</span><span class="p">[</span><span class="n">sourceParent</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sinkParent</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">testing_no_joint_reject</span><span class="p">:</span>
                            <span class="n">admissiblePairs</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                        <span class="c1"># note all vertices with via paths over </span>
                        <span class="c1"># this subsection as not considered</span>
                        <span class="n">admissiblePairs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span>
                                <span class="n">vertexVisitedFromSource</span><span class="p">[</span><span class="n">sourceParent</span><span class="p">],</span>
                                <span class="n">vertexVisitedFromSink</span><span class="p">[</span><span class="n">sinkParent</span><span class="p">],</span>
                                <span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                
                
                <span class="c1"># update the vertex on the source branch</span>
                <span class="n">stopCost</span> <span class="o">=</span> <span class="n">baseCostSink</span> <span class="o">+</span> <span class="n">baseCostSource</span> <span class="o">-</span> <span class="n">sinkCost</span> <span class="o">-</span> <span class="n">T</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">sourceParent</span> <span class="o">=</span> <span class="n">thisSourceVertex</span>
                    <span class="n">sourceCostParent</span> <span class="o">=</span> <span class="n">sourceCost</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">thisSourceVertex</span><span class="p">,</span> <span class="n">sourceCost</span> <span class="o">=</span> \
                                <span class="n">thisReverseSourceLabelData</span><span class="p">[</span><span class="n">thisSourceVertex</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">sourceCostParent</span> <span class="o">&gt;=</span> <span class="n">baseCostSource</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">sourceCost</span> <span class="o">&gt;</span> <span class="n">stopCost</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="c1"># if all tests were sucessful</span>
            <span class="k">else</span><span class="p">:</span>    
                <span class="c1"># only for testing purposes: continue without accepting</span>
                <span class="c1"># further origin-destination pairs</span>
                <span class="k">if</span> <span class="n">testing_no_joint_reject</span><span class="p">:</span>
                    <span class="n">resultSourceIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                    <span class="n">resultSinkIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sink</span><span class="p">)</span>
                    <span class="n">resultLengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="k">continue</span>
                
                <span class="c1"># if we have not stopped the search artificially because of a </span>
                <span class="c1"># too long edge</span>
                <span class="k">if</span> <span class="n">sinkSubpathBound</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sinkSubpathBound</span> <span class="o">=</span> <span class="n">sinkParent</span>
                
                <span class="c1"># we consider all not yet processed pairs for which local </span>
                <span class="c1"># optimality for the tested path is sufficient (taking into </span>
                <span class="c1"># account the acception factor)</span>
                <span class="n">considered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">vertexVisitedFromSource</span><span class="p">[</span><span class="n">sourceSubpathBound</span><span class="p">],</span>
                                    <span class="n">vertexVisitedFromSink</span><span class="p">[</span><span class="n">sinkSubpathBound</span><span class="p">])</span>
                <span class="n">considered2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">admissiblePairs</span><span class="p">[</span><span class="n">considered</span><span class="p">],</span>
                                             <span class="n">distances</span><span class="p">[</span><span class="n">considered</span><span class="p">]</span> 
                                             <span class="o">&lt;=</span> <span class="n">T</span><span class="o">/</span><span class="p">(</span><span class="n">acceptionFactor</span><span class="o">*</span>
                                                   <span class="n">localOptimalityConstant</span><span class="p">)</span><span class="o">*</span><span class="n">rTolFact</span><span class="p">)</span>
                
                <span class="n">sourceProcessIndices</span> <span class="o">=</span> <span class="n">sourcePairIndices</span><span class="p">[</span><span class="n">considered</span><span class="p">][</span><span class="n">considered2</span><span class="p">]</span>
                <span class="n">sinkProcessIndices</span> <span class="o">=</span> <span class="n">sinkPairIndices</span><span class="p">[</span><span class="n">considered</span><span class="p">][</span><span class="n">considered2</span><span class="p">]</span>
                
                <span class="c1"># mark the respective pairs as processed</span>
                <span class="n">admissiblePairs</span><span class="p">[</span><span class="n">sourceProcessIndices</span><span class="p">,</span> 
                                <span class="n">sinkProcessIndices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># note the results</span>
                <span class="n">resultSourceIndices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sourceProcessIndices</span><span class="p">)</span>
                <span class="n">resultSinkIndices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sinkProcessIndices</span><span class="p">)</span>
                <span class="n">resultLengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">considered</span><span class="p">][</span><span class="n">considered2</span><span class="p">])</span>
        
        <span class="c1">########### Be careful with machine imprecision!</span>
        
        <span class="c1"># return result</span>
        <span class="n">admissiblePairNumber</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">resultSourceIndices</span><span class="p">)</span>
        <span class="n">notLO</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairList</span><span class="p">)</span> <span class="o">-</span> <span class="n">admissiblePairNumber</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">vertexIndex</span><span class="p">,</span> <span class="n">consideredSourceIndices</span><span class="p">[</span><span class="n">resultSourceIndices</span><span class="p">],</span> 
                <span class="n">consideredSinkIndices_plain</span><span class="p">[</span><span class="n">resultSinkIndices</span><span class="p">],</span> <span class="n">resultLengths</span><span class="p">,</span> 
                <span class="n">admissiblePairNumber</span><span class="p">,</span> <span class="n">notLO</span><span class="p">)</span> 

    
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_inspection_spots</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">labelData</span><span class="p">,</span> <span class="n">inspectionArr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">labelData</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="s2">&quot;edge&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">inspectionArr</span><span class="p">[</span><span class="n">labelData</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="s2">&quot;edge&quot;</span><span class="p">]]:</span>
            <span class="n">spots</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">inspectionArr</span><span class="p">[</span><span class="n">labelData</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="s2">&quot;edge&quot;</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">thisVertex</span> <span class="o">=</span> <span class="n">labelData</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="s2">&quot;parent_inspection&quot;</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">thisVertex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#print(&quot;thisVertex&quot;, thisVertex)</span>
            <span class="c1">#print(&#39;labelData[thisVertex][&quot;edge&quot;]&#39;, labelData[thisVertex][&quot;edge&quot;])</span>
            <span class="c1">#print(&quot;spots&quot;, inspectionArr[labelData[thisVertex][&quot;edge&quot;]])</span>
            <span class="n">spots</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inspectionArr</span><span class="p">[</span><span class="n">labelData</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;edge&quot;</span><span class="p">]])</span>
            <span class="n">thisVertex</span> <span class="o">=</span> <span class="n">labelData</span><span class="p">[</span><span class="n">thisVertex</span><span class="p">][</span><span class="s2">&quot;parent_inspection&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">spots</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">traceback</span>
    <span class="kn">import</span> <span class="nn">timeit</span>
    <span class="n">iDType</span> <span class="o">=</span> <span class="s2">&quot;|S10&quot;</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    <span class="n">fileNameEdges</span> <span class="o">=</span> <span class="s2">&quot;LakeNetworkExample_full.csv&quot;</span>
    <span class="n">fileNameVertices</span> <span class="o">=</span> <span class="s2">&quot;LakeNetworkExample_full_vertices.csv&quot;</span>
    
    <span class="c1">#fileNameEdges = &quot;LakeNetworkExample_small.csv&quot;</span>
    <span class="c1">#fileNameVertices = &quot;LakeNetworkExample_small_vertices.csv&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fileNameEdges = &quot;ExportEdges.csv&quot;</span>
<span class="sd">    fileNameVertices = &quot;ExportVertices2.csv&quot;</span>
<span class="sd">    #fileNameEdges = &quot;ExportEdges_North.csv&quot;</span>
<span class="sd">    #fileNameVertices = &quot;ExportVertices2.csv&quot;</span>
<span class="sd">    pairList = ((b&#39;231421&#39;, b&#39;768396&#39;),</span>
<span class="sd">                (b&#39;J54131&#39;, b&#39;768396&#39;),</span>
<span class="sd">                (b&#39;J54175&#39;, b&#39;670659&#39;), </span>
<span class="sd">                (b&#39;J54153&#39;, b&#39;998327&#39;), </span>
<span class="sd">                (b&#39;J54163&#39;, b&#39;463830&#39;), </span>
<span class="sd">                (b&#39;J54185&#39;, b&#39;91769&#39;))</span>
<span class="sd">                </span>
<span class="sd">    #pairList = ((b&#39;231421&#39;, b&#39;768396&#39;),)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting test. (29)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading files.&quot;</span><span class="p">)</span>
    
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fileNameEdges</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span>  
                                   <span class="n">skip_header</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                   <span class="n">dtype</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;from_to_original&quot;</span><span class="p">,</span> <span class="s2">&quot;cost&quot;</span><span class="p">,</span> 
                                                     <span class="s2">&quot;inspection&quot;</span><span class="p">,</span> <span class="s2">&quot;lakeID&quot;</span><span class="p">],</span> 
                                            <span class="s1">&#39;formats&#39;</span><span class="p">:[</span><span class="n">iDType</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span> <span class="o">+</span> <span class="n">iDType</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> 
                                                       <span class="s2">&quot;3&quot;</span> <span class="o">+</span> <span class="n">iDType</span><span class="p">,</span> <span class="n">iDType</span><span class="p">]},</span>
                              <span class="n">autostrip</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">vertexData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fileNameVertices</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span>  
                                   <span class="n">skip_header</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                   <span class="n">dtype</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:[</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;infested&quot;</span><span class="p">],</span> 
                                            <span class="s1">&#39;formats&#39;</span><span class="p">:[</span><span class="n">iDType</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">]},</span>
                                   <span class="n">autostrip</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">#TODO: make inspection such that each edge has only one inspection flag!</span>
    <span class="n">ft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;from_to_original&quot;</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="s2">&quot;from_to_original&quot;</span><span class="p">]))</span>
    <span class="n">edata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">edges</span><span class="p">[[</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;inspection&quot;</span><span class="p">,</span> <span class="s2">&quot;lakeID&quot;</span><span class="p">]],</span>
                            <span class="n">edges</span><span class="p">[[</span><span class="s2">&quot;ID&quot;</span><span class="p">,</span> <span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;inspection&quot;</span><span class="p">,</span> <span class="s2">&quot;lakeID&quot;</span><span class="p">]]))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating flexible graph.&quot;</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">FlexibleGraph</span><span class="p">(</span><span class="n">ft</span><span class="p">,</span> <span class="n">edata</span><span class="p">,</span> <span class="n">vertexData</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">],</span> <span class="n">vertexData</span><span class="p">[[</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;infested&quot;</span><span class="p">]],</span>
                      <span class="n">replacementMode</span><span class="o">=</span><span class="s2">&quot;shortest&quot;</span><span class="p">,</span> <span class="n">lengthLabel</span><span class="o">=</span><span class="s2">&quot;cost&quot;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">set_default_vertex_data</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    print(g.get_edge_data(b&#39;2&#39;, b&#39;8&#39;, False))</span>
<span class="sd">    print(g.edges.get_array()[[&quot;fromID&quot;, &quot;toID&quot;]])</span>
<span class="sd">    print(g.edges.get_array().size)</span>
<span class="sd">    print(g.get_neighbor_edges(b&#39;2&#39;, copy=True))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">g</span><span class="o">.</span><span class="n">add_vertex_attributes</span><span class="p">(</span><span class="s2">&quot;significant&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">#g.add_vertex_attributes(&quot;significant&quot;, bool, (True,))</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing insignificant dead ends.&quot;</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">remove_insignificant_dead_ends</span><span class="p">(</span><span class="s2">&quot;significant&quot;</span><span class="p">)</span>
    <span class="c1">#g.vertices.array[&quot;significant&quot;][:] = True</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    print(g.edges.get_array()[[&quot;fromID&quot;, &quot;toID&quot;]])</span>
<span class="sd">    print(g.edges.get_array().size)</span>
<span class="sd">    print(&quot;--------------------------&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#print(&quot;Creating fast graph.&quot;)</span>
    <span class="c1">#g2 = FastGraph(g)</span>
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    print(g2.edges.get_array()[[&quot;fromID&quot;, &quot;toID&quot;]])</span>
<span class="sd">    print(g2.vertices.array)</span>
<span class="sd">    g2.remove_vertex(0)</span>
<span class="sd">    print(g2.edges.get_array()[[&quot;fromID&quot;, &quot;toID&quot;, &quot;fromIndex&quot;, &quot;toIndex&quot;]])</span>
<span class="sd">    print(g2.vertices.get_array().ID)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    parameterList = [(1, 3, 3, (1.5, 1.5, 2.5)), </span>
<span class="sd">                     (1, 3, 4, (1.5, 1.5, 2.5)),</span>
<span class="sd">                     (1, 3, 4, (1, 1, 1.5)),</span>
<span class="sd">                     (1, 3, 4, (2, 2, 3)),</span>
<span class="sd">                     (2, 2, 3, (1.5, 1.5, 2.5)),</span>
<span class="sd">                     (2, 3, 3, (1.5, 1.5, 2.5)),</span>
<span class="sd">                     (0.5, 2, 3, (1.5, 1.5, 2.5)),</span>
<span class="sd">                     (0.5, 3, 4, (1.5, 1.5, 2.5)),</span>
<span class="sd">                     (3, 2, 3, (1.5, 1.5, 2.5)),</span>
<span class="sd">                     (3, 3, 3, (1.5, 1.5, 2.5))]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameterList</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))]</span>
    <span class="c1">#&quot;&quot;&quot;</span>
    
    <span class="n">g3</span> <span class="o">=</span> <span class="n">FlowPointGraph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s2">&quot;cost&quot;</span><span class="p">,</span> <span class="s2">&quot;significant&quot;</span><span class="p">)</span>
    <span class="c1">#g3.set_silent_status(True)</span>
    <span class="n">profile</span><span class="p">(</span><span class="s2">&quot;g3.preprocessing(1, 3, 4, expansionBounds=(2, 2, 3))&quot;</span><span class="p">,</span> 
            <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="n">fromIndices</span> <span class="o">=</span> <span class="n">g3</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">get_array_indices</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">toIndices</span> <span class="o">=</span> <span class="n">g3</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">get_array_indices</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    
    
    <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">parameterList</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating FlowPointGraph.&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preprocessing...&quot;</span><span class="p">)</span>
            
            <span class="n">profile</span><span class="p">(</span><span class="s2">&quot;g3.find_alternative_paths(fromIndices, toIndices, 1.5, 0.2, 1)&quot;</span><span class="p">,</span>
                    <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">())</span>
            
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            prepStr = &quot;g3.preprocessing({}, {}, {}, expansionBounds={})&quot;.format(*parameters)</span>
<span class="sd">            print(prepStr)</span>
<span class="sd">            #profile(&quot;g3.preprocessing(2, 2, 3, expansionBounds=(1.5, 1.5, 2.5))&quot;, globals(), locals())</span>
<span class="sd">            print(&quot;full:&quot;, timeit.timeit(prepStr, number=1, globals=globals()))</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1">#g3.preprocessing(1, 3, expansionBounds=(1, 1.5, 1.5, 2))</span>
            
            <span class="c1">#g3.vertices.array.significant = g3.vertices.array.type &gt; 0 </span>
            
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Packages</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../hybrid_vector_model.html">hybrid_vector_model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ci_rvm.html">ci_rvm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lopaths.html">lopaths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vemomoto_core.html">vemomoto_core</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">VeMoMoTo</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">lopaths.graph</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Samuel M. Fischer.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>